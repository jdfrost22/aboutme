(function () {
  'use strict';

  const urlRegexp = /^([^#]*)(#!)?\/?([^#]*)(#)?(.*)$/;
  class Location {
    constructor(url = "") {
      this.url = url;
      const splitUrl = url.match(urlRegexp);

      if (splitUrl === null) {
        throw new Error("URL parsing failed");
      } else {
        const [, site, hashBangExists, page, hashSignExists, fragment] = splitUrl;
        this.site = site;
        this.page = page || "index";
        this.fragment = window.encodeURI(window.decodeURI(fragment));
        this.isAnchor = !this.isAbsolute && !hashBangExists && hashSignExists;
      }
    }

    get isAbsolute() {
      return this.site !== "";
    }

    getLinkHref(currentPage) {
      if (!this.isAnchor) {
        return this.url;
      }

      return "#!/".concat(currentPage, "#").concat(this.fragment);
    }

  }

  const pathRegexp = /^(\/)?(.+?)?(?:\.([^./]+))?$/;
  class ResourcePath {
    constructor(path, defaultFolder, defaultType) {
      const splitPath = pathRegexp.exec(path);

      if (splitPath === null) {
        this.file = path;
        this.type = defaultType;
      } else {
        const [, isAbsolute, file, type] = splitPath;
        this.file = isAbsolute ? file : "".concat(defaultFolder, "/").concat(file);
        this.type = type || defaultType;
      }
    }

    get url() {
      return "".concat(this.file, ".").concat(this.type);
    }

  }

  function getDocumentRoot() {
    const mainElement = window.document.querySelector("main");

    if (mainElement) {
      return mainElement;
    }

    const firstScript = window.document.querySelector("script");
    const documentRoot = window.document.createElement("main");
    firstScript.parentNode.insertBefore(documentRoot, firstScript);
    return documentRoot;
  }

  function getDocumentTitle() {
    return window.document.title;
  }

  function getDocumentLoader() {
    return getDocumentRoot().innerHTML;
  }

  const Site = {
    root: getDocumentRoot(),
    title: getDocumentTitle(),
    loader: getDocumentLoader()
  };

  class HttpError extends Error {
    constructor(httpErrorCode, defaultMessage = "Unknown error", message = "", details = {}) {
      super("<h1>".concat(defaultMessage, "</h1><strong>").concat(message, "</strong>"));
      this.httpErrorCode = httpErrorCode;
      this.details = details;
    }

  }

  class NotFound extends HttpError {
    constructor(message = "The page you requested does not exist", details = {}) {
      super(404, "404 - Not Found", message, details);
    }

  }

  class ServerError extends HttpError {
    constructor(message = "", details = {}) {
      super(500, "500 - Server Error", message, details);
    }

  }

  class BadRequest extends HttpError {
    constructor(message = "", details = {}) {
      super(300, "300 - Bad Request", message, details);
    }

  }

  class Resource {
    constructor(parse) {
      this.parse = parse;
    }

    async resolve() {
      return "";
    }

  }

  class Data extends Resource {
    constructor(rawData, parse) {
      super(parse);
      this.rawData = rawData;
    }

    async getData() {
      if (this.parsedData !== undefined) {
        return this.parsedData;
      }

      this.parsedData = await this.parse(this.rawData);
      return this.getData();
    }

    async resolve() {
      return this.getData();
    }

  }

  var dependencies = {
  	extramark: "0.3.2",
  	"js-yaml": "3.13.1",
  	mustache: "3.1.0",
  	prismjs: "^1.20.0"
  };

  const dependencies$1 = {
    extramark: {
      name: "extramark",
      version: dependencies.extramark,
      path: "dist/extramark.min.js",
      export: "ExtraMark"
    },
    mustache: {
      name: "mustache",
      version: dependencies.mustache,
      path: "mustache.min.js",
      export: "Mustache"
    },
    prismjs: {
      name: "prismjs",
      version: dependencies.prismjs,
      path: "prism.min.js",
      export: "Prism",

      async callback(dependency, Imports, Prism) {
        await Imports.get("prismjs-autoloader");
        Prism.plugins.autoloader.languages_path = "".concat(Imports.cdnRoot, "/").concat(dependency.name, "@").concat(dependency.version, "/components/");
      }

    },
    "prismjs-autoloader": {
      name: "prismjs",
      version: dependencies.prismjs,
      path: "plugins/autoloader/prism-autoloader.min.js",
      export: "null"
    },
    "js-yaml": {
      name: "js-yaml",
      version: dependencies["js-yaml"],
      path: "dist/js-yaml.min.js",
      export: "jsyaml"
    }
  };

  async function parseJS(rawData, defaultExportName = undefined) {
    // eslint-disable-next-line
    const parse = window.eval.bind(window);
    window.module = {};
    parse("(function (module) {\n      ".concat(rawData, "\n      ").concat(defaultExportName !== undefined ? "module.exports = ".concat(defaultExportName, ";") : "", "\n    })(window.module)"));
    return window.module.exports;
  }

  const cdnRoot = "https://cdn.jsdelivr.net/npm/";
  const Imports = {
    _imports: {},
    cdnRoot,

    async get(importName) {
      if (importName in this._imports) {
        return this._imports[importName];
      }

      if (!(importName in dependencies$1)) {
        throw new Error("Unknown dependency ".concat(importName, "."));
      }

      const dependency = dependencies$1[importName];
      const url = "".concat(dependency.name, "@").concat(dependency.version, "/").concat(dependency.path);
      const fetchResponse = await window.fetch(cdnRoot + url);

      if (!fetchResponse.ok) {
        const errorMessage = "Could not load dependency ".concat(importName, " from ").concat(cdnRoot);

        if (fetchResponse.status === 404) {
          throw new NotFound(errorMessage);
        } else if (fetchResponse.status === 400) {
          throw new BadRequest(errorMessage);
        } else if (fetchResponse.status >= 500) {
          throw new ServerError(errorMessage);
        }
      }

      const sourceCode = await fetchResponse.text(); // eslint-disable-next-line

      this._imports[importName] = await parseJS(sourceCode, dependency.export || undefined);

      if (dependency.callback) {
        await dependency.callback(dependency, Imports, this._imports[importName]);
      }

      return this._imports[importName];
    }

  };

  async function parseYaml(rawData) {
    const JSYaml = await Imports.get("js-yaml");
    const FileYamlType = new JSYaml.Type("!file", {
      kind: "scalar",

      resolve(data) {
        return data !== null;
      },

      construct(data) {
        return new ResourcePath(data, "data", "yaml");
      }

    });
    const YamlWithFilesSchema = JSYaml.Schema.create([FileYamlType]);
    return JSYaml.safeLoad(rawData, {
      schema: YamlWithFilesSchema
    }) || {};
  }

  async function parseJson(rawData) {
    return JSON.parse(rawData);
  }

  const frontMatterRegexp = /^\x2D\x2D\x2D[\t ]*(\r?\n[\s\S]*?\r?\n|\r?\n)\x2D\x2D\x2D[\t ]*\r?\n([\s\S]*)$/;
  class Document extends Resource {
    constructor(rawData, parse) {
      super(parse);
      const splitDocument = frontMatterRegexp.exec(rawData);

      if (splitDocument === null) {
        this.context = new Data("{}", parseJson);
        this.template = rawData;
      } else {
        const [, context, template] = splitDocument;
        this.context = new Data(context, parseYaml);
        this.template = template;
      }
    }

    async getData() {
      return this.context.getData();
    }

    async resolve() {
      const Mustache = await Imports.get("mustache");
      const renderedTemplate = Mustache.render(this.template, (await this.getData()));
      return this.parse(renderedTemplate);
    }

  }

  async function parseMarkdown(rawData) {
    const ExtraMark = await Imports.get("extramark");
    return ExtraMark.render(rawData);
  }

  const Parsers = {
    yaml: {
      type: "data",
      parse: parseYaml
    },
    yml: {
      type: "data",
      parse: parseYaml
    },
    json: {
      type: "data",
      parse: parseJson
    },
    md: {
      type: "document",
      parse: parseMarkdown
    }
  };

  async function resolveResourcePaths(data) {
    if (typeof data !== "object") {
      return;
    }

    for (const field in data) {
      const value = data[field];

      if (value instanceof ResourcePath) {
        // eslint-disable-next-line
        data[field] = await fetchResource(value);
      } else {
        await resolveResourcePaths(value);
      }
    }
  }

  async function fetchResource(resourcePath) {
    if (!Object.keys(Parsers).includes(resourcePath.type)) {
      throw new BadRequest("Invalid resource type requested", resourcePath);
    }

    const fetchResponse = await window.fetch(resourcePath.url, {
      cache: "no-cache"
    });

    if (!fetchResource.ok) {
      if (fetchResponse.status === 404) {
        throw new NotFound();
      } else if (fetchResponse.status === 400) {
        throw new BadRequest();
      } else if (fetchResponse.status >= 500) {
        throw new ServerError();
      }
    }

    try {
      const rawContent = await fetchResponse.text();
      const {
        type,
        parse
      } = Parsers[resourcePath.type];
      let resource;

      if (type === "data") {
        resource = new Data(rawContent, parse);
      } else if (type === "document") {
        resource = new Document(rawContent, parse);
      }

      const data = await resource.getData();
      await resolveResourcePaths(data);
      return resource.resolve();
    } catch (error) {
      if (error instanceof HttpError) {
        throw error;
      }

      throw new ServerError("Invalid content", error);
    }
  }
  async function fetchErrorPage(error) {
    const errorPath = new ResourcePath(error.httpErrorCode, "errors", "md");

    try {
      return await fetchResource(errorPath);
    } catch (_) {
      return error.message;
    }
  }

  const Resources = {
    _resources: {},

    async get(resourcePath) {
      const url = resourcePath.url;

      if (url in this._resources) {
        return this._resources[url];
      }

      try {
        // eslint-disable-next-line
        this._resources[url] = await fetchResource(resourcePath);
      } catch (error) {
        // eslint-disable-next-line
        this._resources[url] = await fetchErrorPage(error);
      }

      return this._resources[url];
    }

  };

  const timeoutUntilLoader = 500;
  async function loadContent(location) {
    const contentPath = new ResourcePath(location.page, "pages", "md");
    const loaderTimer = window.setTimeout(function () {
      Site.root.innerHTML = Site.loader;
    }, timeoutUntilLoader);
    Site.root.innerHTML = await Resources.get(contentPath);
    window.clearTimeout(loaderTimer);
  }

  async function highlightCodeBlocks() {
    if (!document.querySelector("pre > code")) {
      return;
    }

    const Prism = await Imports.get("prismjs");
    Prism.highlightAll();
  }

  function updateActiveLinks(location) {
    const linkElements = document.querySelectorAll("a[href]");

    for (const linkElement of linkElements) {
      const linkHref = linkElement.getAttribute("href");
      const linkLocation = new Location(linkHref);
      const isLinkActive = linkLocation.page === location.page;

      if (linkLocation.isAbsolute) {
        continue;
      }

      linkElement.setAttribute("href", linkLocation.getLinkHref(location.page));
      linkElement.classList.toggle("active", isLinkActive);
    }
  }

  function updateTitle() {
    const firstHeading = document.querySelector("h1");
    document.title = firstHeading ? "".concat(firstHeading.textContent, " | ").concat(Site.title) : "".concat(Site.title);
  }

  function scrollToFragment(location) {
    const fragmentElement = document.getElementById(location.fragment);

    if (fragmentElement !== null) {
      fragmentElement.scrollIntoView({
        block: "start"
      });
    } else {
      window.scrollTo({
        top: 0
      });
    }
  }

  async function navigateToPage(location) {
    await loadContent(location);
    await highlightCodeBlocks();
    updateActiveLinks(location);
    updateTitle();
  }

  async function handleHashChange(event) {
    const currentLocation = new Location(event.newURL);
    const previousLocation = new Location(event.oldURL);

    if (currentLocation.page !== previousLocation.page) {
      await navigateToPage(currentLocation);
    }

    scrollToFragment(currentLocation);
  }
  async function handleLoad() {
    const currentLocation = new Location(window.location.href);
    await navigateToPage(currentLocation);
    scrollToFragment(currentLocation);
  }

  window.addEventListener("hashchange", handleHashChange);
  window.addEventListener("load", handleLoad);

}());
//# sourceMappingURL=gumdrop.js.map
