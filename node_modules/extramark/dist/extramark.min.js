"use strict";var ExtraMark=function(t){'use strict';var we=String.fromCodePoint,Ce=Math.floor,Ae=String.fromCharCode;// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function s(e){var r=$U[e],t,n;if(r)return r;for(r=$U[e]=[],t=0;128>t;t++)n=Ae(t),/^[0-9a-z]$/i.test(n)?r.push(n):r.push("%"+("0"+t.toString(16).toUpperCase()).slice(-2));for(t=0;t<e.length;t++)r[e.charCodeAt(t)]=e[t];return r}// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function o(e,r,t){var n="",a,c,p,u,d;for("string"!=typeof r&&(t=r,r=o.defaultChars),"undefined"==typeof t&&(t=!0),d=s(r),(a=0,c=e.length);a<c;a++){if(p=e.charCodeAt(a),t&&37===p/* % */&&a+2<c&&/^[0-9a-f]{2}$/i.test(e.slice(a+1,a+3))){n+=e.slice(a,a+3),a+=2;continue}if(128>p){n+=d[p];continue}if(55296<=p&&57343>=p){if(55296<=p&&56319>=p&&a+1<c&&(u=e.charCodeAt(a+1),56320<=u&&57343>=u)){n+=encodeURIComponent(e[a]+e[a+1]),a++;continue}n+="%EF%BF%BD";continue}n+=encodeURIComponent(e[a])}return n}function a(e){var r=JU[e],t,n;if(r)return r;for(r=JU[e]=[],t=0;128>t;t++)n=Ae(t),r.push(n);for(t=0;t<e.length;t++)n=e.charCodeAt(t),r[n]="%"+("0"+n.toString(16).toUpperCase()).slice(-2);return r}// Decode percent-encoded string.
//
function l(e,r){var t;return"string"!=typeof r&&(r=l.defaultChars),t=a(r),e.replace(/(%[a-f0-9]{2})+/gi,function(e){var r="",n,s,o,a,c,p,u;for(n=0,s=e.length;n<s;n+=3){if(o=parseInt(e.slice(n+1,n+3),16),128>o){r+=t[o];continue}if(192==(224&o)&&n+3<s&&(a=parseInt(e.slice(n+4,n+6),16),128==(192&a))){u=1984&o<<6|63&a,r+=128>u?"\uFFFD\uFFFD":Ae(u),n+=3;continue}if(224==(240&o)&&n+6<s&&(a=parseInt(e.slice(n+4,n+6),16),c=parseInt(e.slice(n+7,n+9),16),128==(192&a)&&128==(192&c))){u=61440&o<<12|4032&a<<6|63&c,r+=2048>u||55296<=u&&57343>=u?"\uFFFD\uFFFD\uFFFD":Ae(u),n+=6;continue}if(240==(248&o)&&n+9<s&&(a=parseInt(e.slice(n+4,n+6),16),c=parseInt(e.slice(n+7,n+9),16),p=parseInt(e.slice(n+10,n+12),16),128==(192&a)&&128==(192&c)&&128==(192&p))){u=1835008&o<<18|258048&a<<12|4032&c<<6|63&p,65536>u||1114111<u?r+="\uFFFD\uFFFD\uFFFD\uFFFD":(u-=65536,r+=Ae(55296+(u>>10),56320+(1023&u))),n+=9;continue}r+="\uFFFD"}return r})}// Copyright Joyent, Inc. and other Node contributors.
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//
function c(){this.protocol=null,this.slashes=null,this.auth=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.pathname=null}// Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.
/**
	 * new Renderer()
	 *
	 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
	 **/function p(){this.rules=IB({},NB)}/**
	 * Renderer.renderAttrs(token) -> String
	 *
	 * Render token attributes to string.
	 **/ /**
	 * class Ruler
	 *
	 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
	 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
	 *
	 * - keep rules in defined order
	 * - assign the name to each rule
	 * - enable/disable rules
	 * - add/replace rules
	 * - allow assign rules to additional named chains (in the same)
	 * - cacheing lists of active rules
	 *
	 * You will not need use this class directly until write plugins. For simple
	 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
	 * [[MarkdownIt.use]].
	 **/ /**
	 * new Ruler()
	 **/function u(){this.__rules__=[],this.__cache__=null}////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly
// Find rule index by name
//
function d(e){return /^<a[>\s]/i.test(e)}function h(e){return /^<\/a\s*>/i.test(e)}function m(e,r){return FB[r.toLowerCase()]}function g(e){var r=0,t,n;for(t=e.length-1;0<=t;t--)n=e[t],"text"!==n.type||r||(n.content=n.content.replace(ZB,m)),"link_open"===n.type&&"auto"===n.info&&r--,"link_close"===n.type&&"auto"===n.info&&r++}function f(e){var r=0,t,n;for(t=e.length-1;0<=t;t--)n=e[t],"text"===n.type&&!r&&GB.test(n.content)&&(n.content=n.content.replace(/\+-/g,"\xB1")// .., ..., ....... -> …
// but ?..... & !..... -> ?.. & !..
.replace(/\.{2,}/g,"\u2026").replace(/([?!])…/g,"$1..").replace(/([?!]){4,}/g,"$1$1$1").replace(/,{2,}/g,",")// em-dash
.replace(/(^|[^-])---([^-]|$)/mg,"$1\u2014$2")// en-dash
.replace(/(^|\s)--(\s|$)/mg,"$1\u2013$2").replace(/(^|[^-\s])--([^-\s]|$)/mg,"$1\u2013$2")),"link_open"===n.type&&"auto"===n.info&&r--,"link_close"===n.type&&"auto"===n.info&&r++}/* ’ */function b(e,r,t){return e.substr(0,r)+t+e.substr(r+1)}function _(e,r){var n,s,o,a,l,c,p,u,d,h,m,g,f,_,k,y,x,v,q,L,w;for(q=[],n=0;n<e.length;n++){for(s=e[n],p=e[n].level,x=q.length-1;0<=x&&!(q[x].level<=p);x--);if(q.length=x+1,"text"===s.type){o=s.content,l=0,c=o.length;/*eslint no-labels:0,block-scoped-var:0*/OUTER:for(;l<c&&(QB.lastIndex=l,a=QB.exec(o),!!a);){if(k=y=!0,l=a.index+1,v="'"===a[0],d=32,0<=a.index-1)d=o.charCodeAt(a.index-1);else for(x=n-1;0<=x&&"softbreak"!==e[x].type&&"hardbreak"!==e[x].type;x--)// lastChar defaults to 0x20
if("text"===e[x].type){d=e[x].content.charCodeAt(e[x].content.length-1);break}// Find next character,
// default to space if it's the end of the line
//
if(h=32,l<c)h=o.charCodeAt(l);else for(x=n+1;x<e.length&&"softbreak"!==e[x].type&&"hardbreak"!==e[x].type;x++)// nextChar defaults to 0x20
if("text"===e[x].type){h=e[x].content.charCodeAt(0);break}if(m=YB(d)||JB(Ae(d)),g=YB(h)||JB(Ae(h)),f=$B(d),_=$B(h),_?k=!1:g&&!(f||m)&&(k=!1),f?y=!1:m&&!(_||g)&&(y=!1),34===h/* " */&&"\""===a[0]&&48<=d/* 0 */&&57>=d/* 9 */&&(y=k=!1),k&&y&&(k=!1,y=g),!k&&!y){v&&(s.content=b(s.content,a.index,"\u2019"));continue}if(y)// this could be a closing quote, rewind the stack to get a match
for(x=q.length-1;0<=x&&(u=q[x],!(q[x].level<p));x--)if(u.single===v&&q[x].level===p){u=q[x],v?(L=r.md.options.quotes[2],w=r.md.options.quotes[3]):(L=r.md.options.quotes[0],w=r.md.options.quotes[1]),s.content=b(s.content,a.index,w),e[u.token].content=b(e[u.token].content,u.pos,L),l+=w.length-1,u.token===n&&(l+=L.length-1),o=s.content,c=o.length,q.length=x;continue OUTER}k?q.push({token:n,pos:a.index,single:v,level:p}):y&&v&&(s.content=b(s.content,a.index,"\u2019"))}}}}// Token class
/**
	 * class Token
	 **/ /**
	 * new Token(type, tag, nesting)
	 *
	 * Create new token and fill passed properties.
	 **/function k(e,r,t){this.type=e,this.tag=r,this.attrs=null,this.map=null,this.nesting=t,this.level=0,this.children=null,this.content="",this.markup="",this.info="",this.meta=null,this.block=!1,this.hidden=!1}/**
	 * Token.attrIndex(name) -> Number
	 *
	 * Search attribute index by name.
	 **/function y(e,r,t){this.src=e,this.env=t,this.tokens=[],this.inlineMode=!1,this.md=r}// re-export Token class to use in core rules
/**
	 * new Core()
	 **/function x(){this.ruler=new PB;for(var e=0;e<XB.length;e++)this.ruler.push(XB[e][0],XB[e][1])}/**
	 * Core.process(state)
	 *
	 * Executes core chain rules.
	 **/function v(e,r){var t=e.bMarks[r]+e.blkIndent,n=e.eMarks[r];return e.src.substr(t,n-t)}function q(e){var r=[],t=0,n=e.length,s=0,o=0,a=!1,i=0,l;for(l=e.charCodeAt(t);t<n;)96===l/* ` */?a?(a=!1,i=t):0==s%2&&(a=!0,i=t):124===l/* | */&&0==s%2&&!a&&(r.push(e.substring(o,t)),o=t+1),92===l/* \ */?s++:s=0,t++,t===n&&a&&(a=!1,t=i+1),l=e.charCodeAt(t);return r.push(e.substring(o)),r}// Search `[-+*][\n ]`, returns next pos after marker on success
// or -1 on fail.
function L(e,r){var t,n,s,o;// Check bullet
return n=e.bMarks[r]+e.tShift[r],s=e.eMarks[r],t=e.src.charCodeAt(n++),42!==t/* * */&&45!==t/* - */&&43!==t/* + */?-1:n<s&&(o=e.src.charCodeAt(n),!aO(o))?-1:n}// Search `\d+[.)][\n ]`, returns next pos after marker on success
// or -1 on fail.
function w(e,r){var t=e.bMarks[r]+e.tShift[r],n=t,s=e.eMarks[r],o;// List marker should have at least 2 chars (digit + dot)
if(n+1>=s)return-1;if(o=e.src.charCodeAt(n++),48>o/* 0 */||57<o/* 9 */)return-1;for(;;){// EOL -> fail
if(n>=s)return-1;if(o=e.src.charCodeAt(n++),48<=o/* 0 */&&57>=o/* 9 */){// List marker should have no more than 9 digits
// (prevents integer overflow in browsers)
if(10<=n-t)return-1;continue}// found valid marker
if(41===o/* ) */||46===o/* . */)break;return-1}return n<s&&(o=e.src.charCodeAt(n),!aO(o))?-1:n}function C(e,r){var t=e.level+2,n,s;for(n=r+2,s=e.tokens.length-2;n<s;n++)e.tokens[n].level===t&&"paragraph_open"===e.tokens[n].type&&(e.tokens[n+2].hidden=!0,e.tokens[n].hidden=!0,n+=2)}function A(e,r,t,n){var o,a,i,l,c,p,u,d;for(this.src=e,this.md=r,this.env=t,this.tokens=n,this.bMarks=[],this.eMarks=[],this.tShift=[],this.sCount=[],this.bsCount=[],this.blkIndent=0,this.line=0,this.lineMax=0,this.tight=!1,this.ddIndent=-1,this.listIndent=-1,this.parentType="root",this.level=0,this.result="",a=this.src,d=!1,(i=l=p=u=0,c=a.length);l<c;l++){if(o=a.charCodeAt(l),!d)if(vO(o)){p++,9===o?u+=4-u%4:u++;continue}else d=!0;(10===o||l===c-1)&&(10!==o&&l++,this.bMarks.push(i),this.eMarks.push(l),this.tShift.push(p),this.sCount.push(u),this.bsCount.push(0),d=!1,p=0,u=0,i=l+1)}// Push fake entry to simplify cache bounds checks
this.bMarks.push(a.length),this.eMarks.push(a.length),this.tShift.push(0),this.sCount.push(0),this.bsCount.push(0),this.lineMax=this.bMarks.length-1}// Push new token to "stream".
//
/**
	 * new ParserBlock()
	 **/function S(){this.ruler=new PB;for(var e=0;e<qO.length;e++)this.ruler.push(qO[e][0],qO[e][1],{alt:(qO[e][2]||[]).slice()})}// Generate tokens for input range
//
// Skip text characters for text token, place those to pending buffer
// '{}$%@~+=:' reserved for extentions
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
function E(e){return 10/* \n */===e||33/* ! */===e||35/* # */===e||36/* $ */===e||37/* % */===e||38/* & */===e||42/* * */===e||43/* + */===e||45/* - */===e||58/* : */===e||60/* < */===e||61/* = */===e||62/* > */===e||64/* @ */===e||91/* [ */===e||92/* \ */===e||93/* ] */===e||94/* ^ */===e||95/* _ */===e||96/* ` */===e||123/* { */===e||125/* } */===e||126/* ~ */===e}function T(e,r){var t=[],n=r.length,s,o,a,l,c;for(s=0;s<n;s++)(a=r[s],126===a.marker/* ~ */)&&-1!==a.end&&(l=r[a.end],c=e.tokens[a.token],c.type="s_open",c.tag="s",c.nesting=1,c.markup="~~",c.content="",c=e.tokens[l.token],c.type="s_close",c.tag="s",c.nesting=-1,c.markup="~~",c.content="","text"===e.tokens[l.token-1].type&&"~"===e.tokens[l.token-1].content&&t.push(l.token-1));// If a marker sequence has an odd number of characters, it's splitted
// like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
// start of the sequence.
//
// So, we have to move all those markers after subsequent s_close tags.
//
for(;t.length;){for(s=t.pop(),o=s+1;o<e.tokens.length&&"s_close"===e.tokens[o].type;)o++;o--,s!==o&&(c=e.tokens[o],e.tokens[o]=e.tokens[s],e.tokens[s]=c)}}// Walk through delimiter list and replace text tokens with tags
//
function D(e,r){var t=r.length,n,s,o,a,l,c;for(n=t-1;0<=n;n--)(s=r[n],95===s.marker/* _ */||42===s.marker/* * */)&&// Process only opening markers
-1!==s.end&&(o=r[s.end],c=0<n&&r[n-1].end===s.end+1&&r[n-1].token===s.token-1&&r[s.end+1].token===o.token+1&&r[n-1].marker===s.marker,l=Ae(s.marker),a=e.tokens[s.token],a.type=c?"strong_open":"em_open",a.tag=c?"strong":"em",a.nesting=1,a.markup=c?l+l:l,a.content="",a=e.tokens[o.token],a.type=c?"strong_close":"em_close",a.tag=c?"strong":"em",a.nesting=-1,a.markup=c?l+l:l,a.content="",c&&(e.tokens[r[n-1].token].content="",e.tokens[r[s.end+1].token].content="",n--))}// Walk through delimiter list and replace text tokens with tags
//
function I(e){/*eslint no-bitwise:0*/var r=32|e;// to lower case
return 97<=r/* a */&&122>=r/* z */}// For each opening emphasis-like marker find a matching closing one
function z(e,r){var t={},n=r.length,s,o,a,i,l,c,p,u;for(s=0;s<n;s++)if(a=r[s],a.length=a.length||0,a.close){for(t.hasOwnProperty(a.marker)||(t[a.marker]=[-1,-1,-1]),l=t[a.marker][a.length%3],c=-1,o=s-a.jump-1;o>l;o-=i.jump+1)if(i=r[o],i.marker===a.marker&&(-1===c&&(c=o),i.open&&0>i.end&&i.level===a.level&&(p=!1,(i.close||a.open)&&0==(i.length+a.length)%3&&(0!=i.length%3||0!=a.length%3)&&(p=!0),!p))){u=0<o&&!r[o-1].open?r[o-1].jump+1:0,a.jump=s-o+u,a.open=!1,i.end=s,i.jump=u,i.close=!1,c=-1;break}-1!==c&&(t[a.marker][(a.length||0)%3]=c)}// Previously calculated lower bounds (previous fails)
// for each marker and each delimiter length modulo 3.
}function R(e,r,t,n){this.src=e,this.env=t,this.md=r,this.tokens=n,this.tokens_meta=Array(n.length),this.pos=0,this.posMax=this.src.length,this.level=0,this.pending="",this.pendingLevel=0,this.cache={},this.delimiters=[],this._prev_delimiters=[]}// Flush pending text
//
/**
	 * new ParserInline()
	 **/function N(){var e;/**
	   * ParserInline#ruler -> Ruler
	   *
	   * [[Ruler]] instance. Keep configuration of inline rules.
	   **/for(this.ruler=new PB,e=0;e<WO.length;e++)this.ruler.push(WO[e][0],WO[e][1]);/**
	   * ParserInline#ruler2 -> Ruler
	   *
	   * [[Ruler]] instance. Second ruler used for post-processing
	   * (e.g. in emphasis-like rules).
	   **/for(this.ruler2=new PB,e=0;e<QO.length;e++)this.ruler2.push(QO[e][0],QO[e][1])}// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
// Helpers
// Merge objects
//
function M(e/*from1, from2, from3, ...*/){var r=Array.prototype.slice.call(arguments,1);return r.forEach(function(r){r&&Object.keys(r).forEach(function(t){e[t]=r[t]})}),e}function P(e){return Object.prototype.toString.call(e)}function V(e){return"[object String]"===P(e)}function U(e){return"[object Object]"===P(e)}function B(e){return"[object RegExp]"===P(e)}function O(e){return"[object Function]"===P(e)}function j(e){return e.replace(/[.?*+^$[\]\\(){}|-]/g,"\\$&")}////////////////////////////////////////////////////////////////////////////////
function G(e){return Object.keys(e||{}).reduce(function(e,r){return e||re.hasOwnProperty(r)},!1)}/*eslint-enable max-len*/ ////////////////////////////////////////////////////////////////////////////////
function H(e){e.__index__=-1,e.__text_cache__=""}function Z(e){return function(r,t){var n=r.slice(t);return e.test(n)?n.match(e)[0].length:0}}function F(){return function(e,r){r.normalize(e)}}// Schemas compiler. Build regexps.
//
function $(e){function r(e){return e.replace("%TLDS%",n.src_tlds)}// Reset compiled data
function t(e,r){throw new Error("(LinkifyIt) Invalid schema \""+e+"\": "+r)}// Load & clone RE patterns.
var n=e.re=XO(e.__opts__),s=e.__tlds__.slice();// Define dynamic patterns
e.onCompile(),e.__tlds_replaced__||s.push("a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]"),s.push(n.src_xn),n.src_tlds=s.join("|"),n.email_fuzzy=RegExp(r(n.tpl_email_fuzzy),"i"),n.link_fuzzy=RegExp(r(n.tpl_link_fuzzy),"i"),n.link_no_ip_fuzzy=RegExp(r(n.tpl_link_no_ip_fuzzy),"i"),n.host_fuzzy_test=RegExp(r(n.tpl_host_fuzzy_test),"i");//
// Compile each schema
//
var o=[];e.__compiled__={},Object.keys(e.__schemas__).forEach(function(r){var n=e.__schemas__[r];// skip disabled methods
if(null!==n){var s={validate:null,link:null};return e.__compiled__[r]=s,U(n)?(B(n.validate)?s.validate=Z(n.validate):O(n.validate)?s.validate=n.validate:t(r,n),void(O(n.normalize)?s.normalize=n.normalize:n.normalize?t(r,n):s.normalize=F())):V(n)?void o.push(r):void t(r,n)}}),o.forEach(function(r){e.__compiled__[e.__schemas__[r]]&&(e.__compiled__[r].validate=e.__compiled__[e.__schemas__[r]].validate,e.__compiled__[r].normalize=e.__compiled__[e.__schemas__[r]].normalize)}),e.__compiled__[""]={validate:null,normalize:F()};//
// Build schema condition
//
var a=Object.keys(e.__compiled__).filter(function(r){// Filter disabled & fake schemas
return 0<r.length&&e.__compiled__[r]}).map(j).join("|");// (?!_) cause 1.5x slowdown
e.re.schema_test=RegExp("(^|(?!_)(?:[><\uFF5C]|"+n.src_ZPCc+"))("+a+")","i"),e.re.schema_search=RegExp("(^|(?!_)(?:[><\uFF5C]|"+n.src_ZPCc+"))("+a+")","ig"),e.re.pretest=RegExp("("+e.re.schema_test.source+")|("+e.re.host_fuzzy_test.source+")|@","i"),H(e)}/**
	 * class Match
	 *
	 * Match result. Single element of array, returned by [[LinkifyIt#match]]
	 **/function J(e,r){var t=e.__index__,n=e.__last_index__,s=e.__text_cache__.slice(t,n);/**
	   * Match#schema -> String
	   *
	   * Prefix (protocol) for matched string.
	   **/this.schema=e.__schema__.toLowerCase(),this.index=t+r,this.lastIndex=n+r,this.raw=s,this.text=s,this.url=s}function Y(e,r){var t=new J(e,r);return e.__compiled__[t.schema].normalize(t,e),t}/**
	 * class LinkifyIt
	 **/ /**
	 * new LinkifyIt(schemas, options)
	 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
	 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
	 *
	 * Creates new linkifier instance with optional additional schemas.
	 * Can be called without `new` keyword for convenience.
	 *
	 * By default understands:
	 *
	 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
	 * - "fuzzy" links and emails (example.com, foo@bar.com).
	 *
	 * `schemas` is an object, where each key/value describes protocol/rule:
	 *
	 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
	 *   for example). `linkify-it` makes shure that prefix is not preceeded with
	 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
	 * - __value__ - rule to check tail after link prefix
	 *   - _String_ - just alias to existing rule
	 *   - _Object_
	 *     - _validate_ - validator function (should return matched length on success),
	 *       or `RegExp`.
	 *     - _normalize_ - optional function to normalize text & url of matched result
	 *       (for example, for @twitter mentions).
	 *
	 * `options`:
	 *
	 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
	 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
	 *   like version numbers. Default `false`.
	 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
	 *
	 **/function W(e,r){return this instanceof W?void(// Cache last tested result. Used to skip repeating steps on next `match` call.
// Next scan position
!r&&G(e)&&(r=e,e={}),this.__opts__=M({},re,r),this.__index__=-1,this.__last_index__=-1,this.__schema__="",this.__text_cache__="",this.__schemas__=M({},ej,e),this.__compiled__={},this.__tlds__=rj,this.__tlds_replaced__=!1,this.re={},$(this)):new W(e,r)}/** chainable
	 * LinkifyIt#add(schema, definition)
	 * - schema (String): rule name (fixed pattern prefix)
	 * - definition (String|RegExp|Object): schema definition
	 *
	 * Add new rule definition. See constructor description for details.
	 **/ /*--------------------------------------------------------------------------*/ /**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */function Q(e){throw new RangeError(hj[e])}/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */function K(e,r){const t=[];for(let n=e.length;n--;)t[n]=r(e[n]);return t}/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */function X(e,r){const t=e.split("@");let n="";1<t.length&&(n=t[0]+"@",e=t[1]),e=e.replace(dj,".");const s=e.split("."),o=K(s,r).join(".");return n+o}/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */function te(e){const r=[];let t=0;for(const n=e.length;t<n;){const s=e.charCodeAt(t++);if(55296<=s&&56319>=s&&t<n){// It's a high surrogate, and there is a next character.
const n=e.charCodeAt(t++);56320==(64512&n)?r.push(((1023&s)<<10)+(1023&n)+65536):(r.push(s),t--)}else r.push(s)}return r}/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */function se(e){// url should be normalized at this point, and existing entities are decoded
var r=e.trim().toLowerCase();return!Lj.test(r)||!!wj.test(r)}////////////////////////////////////////////////////////////////////////////////
function oe(e){var r=aB.parse(e,!0);if(r.hostname&&(!r.protocol||0<=Cj.indexOf(r.protocol)))// Encode hostnames in urls like:
// `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
//
// We don't encode unknown schemas, because it's likely that we encode
// something we shouldn't (e.g. `skype:name` treated as `skype:host`)
//
try{r.hostname=vj.toASCII(r.hostname)}catch(e){/**/}return aB.encode(aB.format(r))}function ae(e){var r=aB.parse(e,!0);if(r.hostname&&(!r.protocol||0<=Cj.indexOf(r.protocol)))// Encode hostnames in urls like:
// `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
//
// We don't encode unknown schemas, because it's likely that we encode
// something we shouldn't (e.g. `skype:name` treated as `skype:host`)
//
try{r.hostname=vj.toUnicode(r.hostname)}catch(e){/**/}return aB.decode(aB.format(r))}/**
	 * class MarkdownIt
	 *
	 * Main parser/renderer class.
	 *
	 * ##### Usage
	 *
	 * ```javascript
	 * // node.js, "classic" way:
	 * var MarkdownIt = require('markdown-it'),
	 *     md = new MarkdownIt();
	 * var result = md.render('# markdown-it rulezz!');
	 *
	 * // node.js, the same, but with sugar:
	 * var md = require('markdown-it')();
	 * var result = md.render('# markdown-it rulezz!');
	 *
	 * // browser without AMD, added to "window" on script load
	 * // Note, there are no dash.
	 * var md = window.markdownit();
	 * var result = md.render('# markdown-it rulezz!');
	 * ```
	 *
	 * Single line rendering, without paragraph wrap:
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 * var result = md.renderInline('__markdown-it__ rulezz!');
	 * ```
	 **/ /**
	 * new MarkdownIt([presetName, options])
	 * - presetName (String): optional, `commonmark` / `zero`
	 * - options (Object)
	 *
	 * Creates parser instanse with given config. Can be called without `new`.
	 *
	 * ##### presetName
	 *
	 * MarkdownIt provides named presets as a convenience to quickly
	 * enable/disable active syntax rules and options for common use cases.
	 *
	 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
	 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
	 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
	 *   similar to GFM, used when no preset name given. Enables all available rules,
	 *   but still without html, typographer & autolinker.
	 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
	 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
	 *   For example, when you need only `bold` and `italic` markup and nothing else.
	 *
	 * ##### options:
	 *
	 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
	 *   That's not safe! You may need external sanitizer to protect output from XSS.
	 *   It's better to extend features via plugins, instead of enabling HTML.
	 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
	 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
	 *   world you will need HTML output.
	 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
	 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
	 *   Can be useful for external highlighters.
	 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
	 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
	 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
	 *   quotes beautification (smartquotes).
	 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
	 *   pairs, when typographer enabled and smartquotes on. For example, you can
	 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
	 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
	 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
	 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
	 *   return empty string if the source was not changed and should be escaped
	 *   externaly. If result starts with <pre... internal wrapper is skipped.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * // commonmark mode
	 * var md = require('markdown-it')('commonmark');
	 *
	 * // default mode
	 * var md = require('markdown-it')();
	 *
	 * // enable everything
	 * var md = require('markdown-it')({
	 *   html: true,
	 *   linkify: true,
	 *   typographer: true
	 * });
	 * ```
	 *
	 * ##### Syntax highlighting
	 *
	 * ```js
	 * var hljs = require('highlight.js') // https://highlightjs.org/
	 *
	 * var md = require('markdown-it')({
	 *   highlight: function (str, lang) {
	 *     if (lang && hljs.getLanguage(lang)) {
	 *       try {
	 *         return hljs.highlight(lang, str, true).value;
	 *       } catch (__) {}
	 *     }
	 *
	 *     return ''; // use external default escaping
	 *   }
	 * });
	 * ```
	 *
	 * Or with full wrapper override (if you need assign class to `<pre>`):
	 *
	 * ```javascript
	 * var hljs = require('highlight.js') // https://highlightjs.org/
	 *
	 * // Actual default values
	 * var md = require('markdown-it')({
	 *   highlight: function (str, lang) {
	 *     if (lang && hljs.getLanguage(lang)) {
	 *       try {
	 *         return '<pre class="hljs"><code>' +
	 *                hljs.highlight(lang, str, true).value +
	 *                '</code></pre>';
	 *       } catch (__) {}
	 *     }
	 *
	 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
	 *   }
	 * });
	 * ```
	 *
	 **/function ie(e,r){return this instanceof ie?void(/**
	   * MarkdownIt#inline -> ParserInline
	   *
	   * Instance of [[ParserInline]]. You may need it to add new rules when
	   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
	   * [[MarkdownIt.enable]].
	   **/ /**
	   * MarkdownIt#block -> ParserBlock
	   *
	   * Instance of [[ParserBlock]]. You may need it to add new rules when
	   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
	   * [[MarkdownIt.enable]].
	   **/ /**
	   * MarkdownIt#core -> Core
	   *
	   * Instance of [[Core]] chain executor. You may need it to add new rules when
	   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
	   * [[MarkdownIt.enable]].
	   **/ /**
	   * MarkdownIt#renderer -> Renderer
	   *
	   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
	   * rules for new token types, generated by plugins.
	   *
	   * ##### Example
	   *
	   * ```javascript
	   * var md = require('markdown-it')();
	   *
	   * function myToken(tokens, idx, options, env, self) {
	   *   //...
	   *   return result;
	   * };
	   *
	   * md.renderer.rules['my_token'] = myToken
	   * ```
	   *
	   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
	   **/ /**
	   * MarkdownIt#linkify -> LinkifyIt
	   *
	   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
	   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
	   * rule.
	   **/ /**
	   * MarkdownIt#validateLink(url) -> Boolean
	   *
	   * Link validation function. CommonMark allows too much in links. By default
	   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
	   * except some embedded image types.
	   *
	   * You can change this behaviour:
	   *
	   * ```javascript
	   * var md = require('markdown-it')();
	   * // enable everything
	   * md.validateLink = function () { return true; }
	   * ```
	   **/ /**
	   * MarkdownIt#normalizeLink(url) -> String
	   *
	   * Function used to encode link url to a machine-readable format,
	   * which includes url-encoding, punycode, etc.
	   **/ /**
	   * MarkdownIt#normalizeLinkText(url) -> String
	   *
	   * Function used to decode link url to a human-readable format`
	   **/ // Expose utils & helpers for easy acces from plugins
/**
	   * MarkdownIt#utils -> utils
	   *
	   * Assorted utility functions, useful to write plugins. See details
	   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
	   **/ /**
	   * MarkdownIt#helpers -> helpers
	   *
	   * Link components parser functions, useful to write plugins. See details
	   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
	   **/!r&&!dB.isString(e)&&(r=e||{},e="default"),this.inline=new KO,this.block=new LO,this.core=new eO,this.renderer=new MB,this.linkify=new tj,this.validateLink=se,this.normalizeLink=oe,this.normalizeLinkText=ae,this.utils=dB,this.helpers=dB.assign({},DB),this.options={},this.configure(e),r&&this.set(r)):new ie(e,r)}/** chainable
	 * MarkdownIt.set(options)
	 *
	 * Set parser options (in the same format as in constructor). Probably, you
	 * will never need it, but you can change options after constructor call.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')()
	 *             .set({ html: true, breaks: true })
	 *             .set({ typographer, true });
	 * ```
	 *
	 * __Note:__ To achieve the best possible performance, don't modify a
	 * `markdown-it` instance options on the fly. If you need multiple configurations
	 * it's best to create multiple instances and initialize each with separate
	 * config.
	 **/function ce(e,t){var n=e.posMax,s=e.pos,o,a,i;if(94!==e.src.charCodeAt(s)/* ^ */)return!1;if(t)return!1;// don't run any pairs in validation mode
if(s+2>=n)return!1;for(e.pos=s+1;e.pos<n;){if(94===e.src.charCodeAt(e.pos)/* ^ */){o=!0;break}e.md.inline.skipToken(e)}return o&&s+1!==e.pos?(a=e.src.slice(s+1,e.pos),a.match(/(^|[^\\])(\\\\)*\s/))?(e.pos=s,!1):(e.posMax=e.pos,e.pos=s+1,i=e.push("sup_open","sup",1),i.markup="^",i=e.push("text","",0),i.content=a.replace(r,"$1"),i=e.push("sup_close","sup",-1),i.markup="^",e.pos=e.posMax+1,e.posMax=n,!0):(e.pos=s,!1);// found!
}function pe(e,r){var t=e.posMax,s=e.pos,o,a,i;if(126!==e.src.charCodeAt(s)/* ~ */)return!1;if(r)return!1;// don't run any pairs in validation mode
if(s+2>=t)return!1;for(e.pos=s+1;e.pos<t;){if(126===e.src.charCodeAt(e.pos)/* ~ */){o=!0;break}e.md.inline.skipToken(e)}return o&&s+1!==e.pos?(a=e.src.slice(s+1,e.pos),a.match(/(^|[^\\])(\\\\)*\s/))?(e.pos=s,!1):(e.posMax=e.pos,e.pos=s+1,i=e.push("sub_open","sub",1),i.markup="~",i=e.push("text","",0),i.content=a.replace(n,"$1"),i=e.push("sub_close","sub",-1),i.markup="~",e.pos=e.posMax+1,e.posMax=t,!0):(e.pos=s,!1);// found!
}// Process footnotes
// Renderer partials
function ue(e,r,t,s/*, slf*/){var o=(+(e[r].meta.id+1)).toString(),n="";return"string"==typeof s.docId&&(n="-"+s.docId+"-"),n+o}function de(e,r/*, options, env, slf*/){var t=(+(e[r].meta.id+1)).toString();return 0<e[r].meta.subId&&(t+=":"+e[r].meta.subId),"["+t+"]"}function he(e,r,t,n,s){var o=s.rules.footnote_anchor_name(e,r,t,n,s),a=s.rules.footnote_caption(e,r,t,n,s),i=o;return 0<e[r].meta.subId&&(i+=":"+e[r].meta.subId),"<sup class=\"footnote-ref\"><a href=\"#fn"+o+"\" id=\"fnref"+i+"\">"+a+"</a></sup>"}function me(e,r,t){return(t.xhtmlOut?"<hr class=\"footnotes-sep\" />\n":"<hr class=\"footnotes-sep\">\n")+"<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n"}function fe(){return"</ol>\n</section>\n"}function be(e,r,t,n,s){var o=s.rules.footnote_anchor_name(e,r,t,n,s);return 0<e[r].meta.subId&&(o+=":"+e[r].meta.subId),"<li id=\"fn"+o+"\" class=\"footnote-item\">"}function _e(){return"</li>\n"}function ke(e,r,t,n,s){var o=s.rules.footnote_anchor_name(e,r,t,n,s);/* ↩ with escape code to prevent display as Apple Emoji on iOS */return 0<e[r].meta.subId&&(o+=":"+e[r].meta.subId)," <a href=\"#fnref"+o+"\" class=\"footnote-backref\">\u21A9\uFE0E</a>"}function ye(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function xe(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),t.push.apply(t,n)}return t}function ve(e){for(var r=1,t;r<arguments.length;r++)t=null==arguments[r]?{}:arguments[r],r%2?xe(t,!0).forEach(function(r){ye(e,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):xe(t).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))});return e}function qe(e){return e.replace(Dj.regex,Dj.render).replace(Ej.regex,Ej.render).replace(Tj.regex,Tj.render).replace(Rj.regex,Rj.render).replace(zj.regex,zj.render)}function Le(e){e.src=qe(e.src)}var Se="\xE1",Ee="\u0102",Te="\u0103",De="\u223E",Ie="\u223F",ze="\u223E\u0333",Ne="\xC2",Me="\xE2",Pe="\xB4",Ve="\u0410",Ue="\u0430",Be="\xC6",Oe="\xE6",je="\u2061",Ge="\uD835\uDD04",He="\uD835\uDD1E",Ze="\xC0",Fe="\xE0",$e="\u2135",Je="\u2135",Ye="\u0391",We="\u03B1",Qe="\u0100",Ke="\u0101",Xe="\u2A3F",er="&",rr="&",tr="\u2A55",nr="\u2A53",sr="\u2227",ar="\u2A5C",ir="\u2A58",lr="\u2A5A",cr="\u2220",ur="\u29A4",dr="\u2220",hr="\u29A8",mr="\u29A9",gr="\u29AA",fr="\u29AB",br="\u29AC",_r="\u29AD",kr="\u29AE",yr="\u29AF",xr="\u2221",vr="\u221F",qr="\u22BE",Lr="\u299D",Cr="\u2222",Ar="\xC5",Sr="\u237C",Er="\u0104",Tr="\u0105",Dr="\uD835\uDD38",Ir="\uD835\uDD52",zr="\u2A6F",Rr="\u2248",Nr="\u2A70",Mr="\u224A",Vr="\u224B",Ur="'",Br="\u2061",jr="\u2248",Gr="\u224A",Hr="\xC5",Zr="\xE5",Fr="\uD835\uDC9C",$r="\uD835\uDCB6",Jr="\u2254",Yr="*",Wr="\u2248",Qr="\u224D",Kr="\xC3",Xr="\xE3",et="\xC4",rt="\xE4",tt="\u2233",nt="\u2A11",st="\u224C",ot="\u03F6",at="\u2035",ct="\u223D",pt="\u22CD",ut="\u2216",dt="\u2AE7",ht="\u22BD",mt="\u2305",ft="\u2306",bt="\u2305",_t="\u23B5",kt="\u23B6",yt="\u224C",xt="\u0411",vt="\u0431",qt="\u201E",wt="\u2235",Ct="\u2235",At="\u2235",St="\u29B0",Et="\u03F6",Tt="\u212C",Dt="\u212C",It="\u0392",zt="\u03B2",Rt="\u2136",Nt="\u226C",Mt="\uD835\uDD05",Pt="\uD835\uDD1F",Vt="\u22C2",Ut="\u25EF",Bt="\u22C3",Ot="\u2A00",jt="\u2A01",Ht="\u2A02",Zt="\u2A06",Ft="\u2605",$t="\u25BD",Jt="\u25B3",Yt="\u2A04",Wt="\u22C1",Qt="\u22C0",Kt="\u290D",Xt="\u29EB",en="\u25AA",rn="\u25B4",tn="\u25BE",nn="\u25C2",sn="\u25B8",on="\u2423",an="\u2592",ln="\u2591",cn="\u2593",pn="\u2588",un="=\u20E5",dn="\u2261\u20E5",hn="\u2AED",mn="\u2310",gn="\uD835\uDD39",fn="\uD835\uDD53",bn="\u22A5",_n="\u22A5",kn="\u22C8",yn="\u29C9",xn="\u2510",vn="\u2555",qn="\u2556",Ln="\u2557",wn="\u250C",Cn="\u2552",An="\u2553",Sn="\u2554",En="\u2500",Tn="\u2550",Dn="\u252C",In="\u2564",zn="\u2565",Rn="\u2566",Nn="\u2534",Mn="\u2567",Pn="\u2568",Vn="\u2569",Un="\u229F",Bn="\u229E",On="\u22A0",jn="\u2518",Gn="\u255B",Hn="\u255C",Zn="\u255D",Fn="\u2514",$n="\u2558",Jn="\u2559",Yn="\u255A",Wn="\u2502",Qn="\u2551",Kn="\u253C",Xn="\u256A",es="\u256B",rs="\u256C",ts="\u2524",ns="\u2561",ss="\u2562",os="\u2563",as="\u251C",is="\u255E",ls="\u255F",cs="\u2560",ps="\u2035",us="\u02D8",ds="\u02D8",hs="\xA6",ms="\uD835\uDCB7",gs="\u212C",fs="\u204F",bs="\u223D",_s="\u22CD",ks="\u29C5",ys="\\",xs="\u27C8",vs="\u2022",qs="\u2022",Ls="\u224E",ws="\u2AAE",Cs="\u224F",As="\u224E",Ss="\u224F",Es="\u0106",Ts="\u0107",Ds="\u2A44",Is="\u2A49",zs="\u2A4B",Rs="\u2229",Ns="\u22D2",Ms="\u2A47",Ps="\u2A40",Vs="\u2145",Us="\u2229\uFE00",Bs="\u2041",Os="\u02C7",js="\u212D",Gs="\u2A4D",Hs="\u010C",Zs="\u010D",Fs="\xC7",$s="\xE7",Js="\u0108",Ys="\u0109",Ws="\u2230",Qs="\u2A4C",Ks="\u2A50",Xs="\u010A",eo="\u010B",ro="\xB8",to="\xB8",no="\u29B2",so="\xA2",oo="\xB7",ao="\xB7",io="\uD835\uDD20",lo="\u212D",co="\u0427",po="\u0447",uo="\u2713",ho="\u2713",mo="\u03A7",go="\u03C7",fo="\u02C6",bo="\u2257",_o="\u21BA",ko="\u21BB",yo="\u229B",xo="\u229A",vo="\u229D",qo="\u2299",Lo="\xAE",wo="\u24C8",Co="\u2296",Ao="\u2295",So="\u2297",Eo="\u25CB",To="\u29C3",Do="\u2257",Io="\u2A10",zo="\u2AEF",Ro="\u29C2",No="\u2232",Mo="\u201D",Po="\u2019",Vo="\u2663",Uo="\u2663",Bo=":",Oo="\u2237",jo="\u2A74",Go="\u2254",Ho="\u2254",Zo=",",Fo="@",$o="\u2201",Jo="\u2218",Yo="\u2201",Wo="\u2102",Qo="\u2245",Ko="\u2A6D",Xo="\u2261",ea="\u222E",ra="\u222F",ta="\u222E",na="\uD835\uDD54",sa="\u2102",oa="\u2210",aa="\u2210",ia="\xA9",la="\xA9",ca="\u2117",pa="\u2233",ua="\u21B5",da="\u2717",ha="\u2A2F",ma="\uD835\uDC9E",ga="\uD835\uDCB8",fa="\u2ACF",ba="\u2AD1",_a="\u2AD0",ka="\u2AD2",ya="\u22EF",xa="\u2938",va="\u2935",qa="\u22DE",La="\u22DF",wa="\u21B6",Ca="\u293D",Aa="\u2A48",Sa="\u2A46",Ea="\u224D",Ta="\u222A",Da="\u22D3",Ia="\u2A4A",za="\u228D",Ra="\u2A45",Na="\u222A\uFE00",Ma="\u21B7",Pa="\u293C",Va="\u22DE",Ua="\u22DF",Ba="\u22CE",Oa="\u22CF",ja="\xA4",Ga="\u21B6",Ha="\u21B7",Za="\u22CE",Fa="\u22CF",$a="\u2232",Ja="\u2231",Ya="\u232D",Wa="\u2020",Qa="\u2021",Ka="\u2138",Xa="\u2193",ei="\u21A1",ri="\u21D3",ti="\u2010",si="\u2AE4",oi="\u22A3",ai="\u290F",li="\u02DD",ci="\u010E",ui="\u010F",di="\u0414",hi="\u0434",mi="\u2021",gi="\u21CA",fi="\u2145",bi="\u2146",_i="\u2911",ki="\u2A77",yi="\xB0",vi="\u2207",qi="\u0394",Li="\u03B4",wi="\u29B1",Ci="\u297F",Ai="\uD835\uDD07",Si="\uD835\uDD21",Ei="\u2965",Ti="\u21C3",Di="\u21C2",Ii="\xB4",zi="\u02D9",Ri="\u02DD",Ni="`",Mi="\u02DC",Vi="\u22C4",Ui="\u22C4",Bi="\u22C4",Oi="\u2666",ji="\u2666",Gi="\xA8",Hi="\u2146",Zi="\u03DD",Fi="\u22F2",$i="\xF7",Ji="\xF7",Yi="\u22C7",Wi="\u22C7",Qi="\u0402",Ki="\u0452",rl="\u231E",tl="\u230D",nl="$",sl="\uD835\uDD3B",ol="\uD835\uDD55",al="\xA8",il="\u02D9",cl="\u20DC",pl="\u2250",ul="\u2251",dl="\u2250",hl="\u2238",ml="\u2214",fl="\u22A1",bl="\u2306",_l="\u222F",kl="\xA8",yl="\u21D3",xl="\u21D0",vl="\u21D4",ql="\u2AE4",wl="\u27F8",Cl="\u27FA",Al="\u27F9",Sl="\u21D2",El="\u22A8",Tl="\u21D1",Dl="\u21D5",Il="\u2225",zl="\u2913",Rl="\u2193",Nl="\u2193",Ml="\u21D3",Pl="\u21F5",Vl="\u0311",Ul="\u21CA",Bl="\u21C3",Ol="\u21C2",jl="\u2950",Gl="\u295E",Hl="\u2956",Zl="\u21BD",Fl="\u295F",$l="\u2957",Jl="\u21C1",Yl="\u21A7",Wl="\u22A4",Ql="\u2910",Kl="\u231F",Xl="\u230C",ec="\uD835\uDC9F",rc="\uD835\uDCB9",tc="\u0405",nc="\u0455",oc="\u29F6",ac="\u0110",lc="\u0111",cc="\u22F1",pc="\u25BF",uc="\u25BE",dc="\u21F5",hc="\u296F",mc="\u29A6",gc="\u040F",fc="\u045F",bc="\u27FF",_c="\xC9",kc="\xE9",yc="\u2A6E",xc="\u011A",vc="\u011B",qc="\xCA",Lc="\xEA",wc="\u2256",Cc="\u2255",Ac="\u042D",Ec="\u044D",Tc="\u2A77",Dc="\u0116",Ic="\u0117",zc="\u2251",Rc="\u2147",ee="\u2252",Nc="\uD835\uDD08",Mc="\uD835\uDD22",Pc="\u2A9A",Vc="\xC8",Uc="\xE8",Bc="\u2A96",Oc="\u2A98",jc="\u2A99",el="\u2208",Gc="\u23E7",Hc="\u2113",Zc="\u2A95",Fc="\u2A97",$c="\u0112",Jc="\u0113",Yc="\u2205",Wc="\u2205",Qc="\u25FB",Kc="\u2205",Xc="\u25AB",ep="\u2004",rp="\u2005",tp="\u2003",np="\u014A",sp="\u014B",op="\u2002",ap="\u0118",ip="\u0119",lp="\uD835\uDD3C",cp="\uD835\uDD56",pp="\u22D5",up="\u29E3",dp="\u2A71",hp="\u03B5",gp="\u0395",fp="\u03B5",bp="\u03F5",_p="\u2256",kp="\u2255",yp="\u2242",xp="\u2A96",vp="\u2A95",qp="\u2A75",Lp="=",Cp="\u2242",Ap="\u225F",Sp="\u21CC",Ep="\u2261",Tp="\u2A78",Dp="\u29E5",Ip="\u2971",zp="\u2253",Rp="\u212F",Np="\u2130",Mp="\u2250",Pp="\u2A73",Vp="\u2242",Up="\u0397",Bp="\u03B7",Op="\xD0",jp="\xF0",Gp="\xCB",Hp="\xEB",Zp="\u20AC",Fp="!",$p="\u2203",Jp="\u2203",Yp="\u2130",Wp="\u2147",Qp="\u2147",Kp="\u2252",Xp="\u0424",eu="\u0444",ru="\u2640",tu="\uFB03",su="\uFB00",ou="\uFB04",au="\uD835\uDD09",iu="\uD835\uDD23",lu="\uFB01",cu="\u25FC",pu="\u25AA",uu="fj",du="\u266D",hu="\uFB02",gu="\u25B1",fu="\u0192",bu="\uD835\uDD3D",_u="\uD835\uDD57",ku="\u2200",yu="\u2200",xu="\u22D4",vu="\u2AD9",qu="\u2131",Lu="\u2A0D",wu="\xBD",Cu="\u2153",Au="\xBC",Su="\u2155",Eu="\u2159",Tu="\u215B",Du="\u2154",Iu="\u2156",zu="\xBE",Ru="\u2157",Pu="\u215C",Vu="\u2158",Uu="\u215A",Bu="\u215D",Ou="\u215E",ju="\u2044",Gu="\u2322",Hu="\uD835\uDCBB",Zu="\u2131",Fu="\u01F5",$u="\u0393",Ju="\u03B3",Yu="\u03DC",Wu="\u03DD",Qu="\u2A86",Ku="\u011E",Xu="\u011F",ed="\u0122",rd="\u011C",td="\u011D",nd="\u0413",sd="\u0433",od="\u0120",ad="\u0121",id="\u2265",ge="\u2267",ld="\u2A8C",cd="\u22DB",pd="\u2265",ud="\u2267",dd="\u2A7E",hd="\u2AA9",md="\u2A7E",gd="\u2A80",fd="\u2A82",bd="\u2A84",_d="\u22DB\uFE00",kd="\u2A94",yd="\uD835\uDD0A",xd="\uD835\uDD24",vd="\u226B",qd="\u22D9",Ld="\u22D9",wd="\u2137",Cd="\u0403",Ad="\u0453",Sd="\u2AA5",Ed="\u2277",gl="\u2A92",Td="\u2AA4",Dd="\u2A8A",Id="\u2A8A",zd="\u2A88",Rd="\u2269",Nd="\u2A88",Md="\u2269",Pd="\u22E7",Vd="\uD835\uDD3E",Ud="\uD835\uDD58",Bd="`",Od="\u2265",jd="\u22DB",Gd="\u2267",Hd="\u2AA2",Zd="\u2277",Fd="\u2A7E",$d="\u2273",Jd="\uD835\uDCA2",Yd="\u210A",Wd="\u2273",Qd="\u2A8E",Kd="\u2A90",Xd="\u2AA7",eh="\u2A7A",rh=">",gt=">",th="\u226B",Gt="\u22D7",nh="\u2995",sh="\u2A7C",oh="\u2A86",ah="\u2978",ih="\u22D7",lh="\u22DB",ch="\u2A8C",ph="\u2277",uh="\u2273",dh="\u2269\uFE00",hh="\u2269\uFE00",mh="\u02C7",gh="\u200A",fh="\xBD",bh="\u210B",_h="\u042A",kh="\u044A",yh="\u2948",xh="\u2194",vh="\u21D4",qh="\u21AD",Lh="^",wh="\u210F",Ch="\u0124",Ah="\u0125",Sh="\u2665",Eh="\u2665",Th="\u2026",Dh="\u22B9",Ih="\uD835\uDD25",zh="\u210C",Rh="\u210B",Nh="\u2925",Mh="\u2926",Ph="\u21FF",Vh="\u223B",Uh="\u21A9",Bh="\u21AA",Oh="\uD835\uDD59",jh="\u210D",Gh="\u2015",Hh="\u2500",Zh="\uD835\uDCBD",Fh="\u210B",$h="\u210F",Jh="\u0126",Yh="\u0127",Wh="\u224E",Qh="\u224F",Kh="\u2043",Xh="\u2010",em="\xCD",rm="\xED",tm="\u2063",ic="\xCE",nm="\xEE",sm="\u0418",om="\u0438",am="\u0130",im="\u0415",lm="\u0435",cm="\xA1",um="\u21D4",dm="\uD835\uDD26",hm="\u2111",mm="\xCC",gm="\xEC",fm="\u2148",ii="\u2A0C",bm="\u222D",_m="\u29DC",km="\u2129",ym="\u0132",xm="\u0133",vm="\u012A",qm="\u012B",Lm="\u2111",wm="\u2148",Cm="\u2110",Am="\u2111",Sm="\u0131",Em="\u2111",Tm="\u22B7",Dm="\u01B5",Im="\u21D2",zm="\u2105",Rm="\u221E",Nm="\u29DD",Mm="\u0131",Pm="\u22BA",Vm="\u222B",Um="\u222C",Bm="\u2124",Om="\u222B",jm="\u22BA",Gm="\u22C2",Hm="\u2A17",Zm="\u2A3C",Fm="\u2063",$m="\u2062",Jm="\u0401",Ym="\u0451",Wm="\u012E",Qm="\u012F",Km="\uD835\uDD40",Xm="\uD835\uDD5A",eg="\u0399",rg="\u03B9",tg="\u2A3C",ng="\xBF",sg="\uD835\uDCBE",og="\u2110",ag="\u2208",ig="\u22F5",cg="\u22F9",pg="\u22F4",ug="\u22F3",dg="\u2208",hg="\u2062",it="\u0128",mg="\u0129",gg="\u0406",fg="\u0456",bg="\xCF",_g="\xEF",kg="\u0134",yg="\u0135",xg="\u0419",vg="\u0439",qg="\uD835\uDD0D",Lg="\uD835\uDD27",wg="\u0237",Cg="\uD835\uDD41",Ag="\uD835\uDD5B",Sg="\uD835\uDCA5",Eg="\uD835\uDCBF",Tg="\u0408",Dg="\u0458",Ig="\u0404",zg="\u0454",Rg="\u039A",Ng="\u03BA",Mg="\u03F0",Pg="\u0136",Vg="\u0137",Ug="\u041A",Bg="\u043A",Og="\uD835\uDD0E",jg="\uD835\uDD28",Gg="\u0138",Hg="\u0425",Zg="\u0445",Fg="\u040C",$g="\u045C",Jg="\uD835\uDD42",Yg="\uD835\uDD5C",Wg="\uD835\uDCA6",Qg="\uD835\uDCC0",Kg="\u21DA",Xg="\u0139",ef="\u013A",rf="\u29B4",tf="\u2112",nf="\u039B",sf="\u03BB",of="\u27E8",af="\u27EA",lf="\u2991",cf="\u27E8",pf="\u2A85",uf="\u2112",df="\xAB",hf="\u21E4",mf="\u291F",gf="\u2190",ff="\u219E",bf="\u21D0",_f="\u291D",kf="\u21A9",yf="\u21AB",xf="\u2939",vf="\u2973",qf="\u21A2",Lf="\u2919",wf="\u291B",Cf="\u2AAB",Af="\u2AAD",Sf="\u2AAD\uFE00",Ef="\u290C",Tf="\u290E",Df="\u2772",If="{",zf="[",Rf="\u298B",Nf="\u298F",Mf="\u298D",Pf="\u013D",Vf="\u013E",Uf="\u013B",Bf="\u013C",Of="\u2308",jf="{",Gf="\u041B",Hf="\u043B",Zf="\u2936",Ff="\u201C",$f="\u201E",Jf="\u2967",Yf="\u294B",Wf="\u21B2",Qf="\u2264",le="\u2266",Kf="\u27E8",Xf="\u21E4",eb="\u2190",rb="\u2190",tb="\u21D0",nb="\u21C6",sb="\u21A2",ob="\u2308",ab="\u27E6",ib="\u2961",lb="\u2959",cb="\u21C3",pb="\u230A",ub="\u21BD",db="\u21BC",hb="\u21C7",mb="\u2194",gb="\u2194",fb="\u21D4",bb="\u21C6",_b="\u21CB",kb="\u21AD",yb="\u294E",xb="\u21A4",vb="\u22A3",qb="\u295A",Lb="\u22CB",wb="\u29CF",Cb="\u22B2",Ab="\u22B4",Sb="\u2951",Eb="\u2960",Tb="\u2958",Db="\u21BF",Ib="\u2952",zb="\u21BC",Rb="\u2A8B",Nb="\u22DA",Mb="\u2264",Pb="\u2266",Vb="\u2A7D",Ub="\u2AA8",Bb="\u2A7D",Ob="\u2A7F",jb="\u2A81",Gb="\u2A83",Hb="\u22DA\uFE00",Zb="\u2A93",Fb="\u2A85",$b="\u22D6",Jb="\u22DA",Yb="\u2A8B",Wb="\u22DA",Qb="\u2266",Kb="\u2276",Xb="\u2276",e_="\u2AA1",r_="\u2272",t_="\u2A7D",n_="\u2272",s_="\u297C",o_="\u230A",a_="\uD835\uDD0F",i_="\uD835\uDD29",l_="\u2276",lg="\u2A91",c_="\u2962",p_="\u21BD",u_="\u21BC",d_="\u296A",h_="\u2584",m_="\u0409",g_="\u0459",f_="\u21C7",b_="\u226A",ll="\u22D8",Ll="\u231E",__="\u21DA",k_="\u296B",y_="\u25FA",x_="\u013F",v_="\u0140",q_="\u23B0",L_="\u23B0",w_="\u2A89",C_="\u2A89",A_="\u2A87",S_="\u2268",E_="\u2A87",T_="\u2268",D_="\u22E6",I_="\u27EC",z_="\u21FD",R_="\u27E6",N_="\u27F5",M_="\u27F5",P_="\u27F8",V_="\u27F7",U_="\u27F7",B_="\u27FA",O_="\u27FC",j_="\u27F6",G_="\u27F6",H_="\u27F9",Z_="\u21AB",F_="\u21AC",$_="\u2985",J_="\uD835\uDD43",Y_="\uD835\uDD5D",W_="\u2A2D",Q_="\u2A34",K_="\u2217",X_="_",ek="\u2199",rk="\u2198",tk="\u25CA",nk="\u25CA",sk="\u29EB",ok="(",ak="\u2993",ik="\u21C6",lk="\u231F",ck="\u21CB",pk="\u296D",uk="\u200E",dk="\u22BF",hk="\u2039",mk="\uD835\uDCC1",gk="\u2112",fk="\u21B0",bk="\u21B0",_k="\u2272",kk="\u2A8D",yk="\u2A8F",xk="[",vk="\u2018",qk="\u201A",Lk="\u0141",wk="\u0142",Ck="\u2AA6",Ak="\u2A79",Sk="<",lt="<",Ek="\u226A",Lt="\u22D6",Tk="\u22CB",Dk="\u22C9",Ik="\u2976",zk="\u2A7B",Rk="\u25C3",Nk="\u22B4",Mk="\u25C2",Pk="\u2996",Vk="\u294A",Uk="\u2966",Bk="\u2268\uFE00",Ok="\u2268\uFE00",jk="\xAF",Gk="\u2642",Hk="\u2720",Zk="\u2720",Fk="\u21A6",$k="\u21A6",Jk="\u21A7",Yk="\u21A4",Wk="\u21A5",Qk="\u25AE",Kk="\u2A29",Xk="\u041C",ey="\u043C",ry="\u2014",ty="\u223A",ny="\u2221",sy="\u205F",oy="\u2133",ay="\uD835\uDD10",iy="\uD835\uDD2A",ly="\u2127",cy="\xB5",py="*",uy="\u2AF0",dy="\u2223",hy="\xB7",my="\u229F",gy="\u2212",fy="\u2238",by="\u2A2A",_y="\u2213",ky="\u2ADB",yy="\u2026",xy="\u2213",vy="\u22A7",qy="\uD835\uDD44",Ly="\uD835\uDD5E",wy="\u2213",mp="\uD835\uDCC2",Cy="\u2133",Ay="\u223E",Sy="\u039C",Mu="\u03BC",mu="\u22B8",Ey="\u22B8",Ty="\u2207",Dy="\u0143",Iy="\u0144",zy="\u2220\u20D2",Ry="\u2249",Ny="\u2A70\u0338",My="\u224B\u0338",Py="\u0149",Vy="\u2249",Uy="\u266E",By="\u2115",Oy="\u266E",jy="\xA0",Gy="\u224E\u0338",Hy="\u224F\u0338",Zy="\u2A43",Fy="\u0147",$y="\u0148",Jy="\u0145",Yy="\u0146",Wy="\u2247",Qy="\u2A6D\u0338",Ky="\u2A42",Xy="\u041D",ex="\u043D",tx="\u2013",nx="\u2924",sx="\u2197",ox="\u21D7",ax="\u2197",ix="\u2260",ne="\u2250\u0338",lx="\u200B",cx="\u200B",px="\u200B",ux="\u200B",dx="\u2262",hx="\u2928",mx="\u2242\u0338",gx="\u226B",fx="\u226A",bx="\n",_x="\u2204",kx="\u2204",yx="\uD835\uDD11",xx="\uD835\uDD2B",vx="\u2267\u0338",qx="\u2271",Lx="\u2271",wx="\u2267\u0338",Cx="\u2A7E\u0338",Ax="\u2A7E\u0338",Sx="\u22D9\u0338",Ex="\u2275",Tx="\u226B\u20D2",Dx="\u226F",Ix="\u226F",zx="\u226B\u0338",Rx="\u21AE",Nx="\u21CE",Mx="\u2AF2",Px="\u220B",ni="\u22FC",Vx="\u22FA",Ux="\u220B",Bx="\u040A",Ox="\u045A",jx="\u219A",Gx="\u21CD",Hx="\u2025",Zx="\u2266\u0338",Fx="\u2270",$x="\u219A",Jx="\u21CD",Yx="\u21AE",Wx="\u21CE",Qx="\u2270",Kx="\u2266\u0338",Xx="\u2A7D\u0338",ev="\u2A7D\u0338",rv="\u226E",tv="\u22D8\u0338",nv="\u2274",sv="\u226A\u20D2",ov="\u226E",av="\u22EA",iv="\u22EC",lv="\u226A\u0338",cv="\u2224",pv="\u2060",uv="\xA0",dv="\uD835\uDD5F",hv="\u2115",mv="\u2AEC",gv="\xAC",fv="\u2262",bv="\u226D",_v="\u2226",kv="\u2209",yv="\u2260",xv="\u2242\u0338",vv="\u2204",qv="\u226F",Lv="\u2271",wv="\u2267\u0338",Cv="\u226B\u0338",Av="\u2279",Sv="\u2A7E\u0338",Ev="\u2275",Tv="\u224E\u0338",Dv="\u224F\u0338",Iv="\u2209",zv="\u22F5\u0338",Rv="\u22F9\u0338",Nv="\u2209",Mv="\u22F7",Pv="\u22F6",Vv="\u29CF\u0338",Uv="\u22EA",Bv="\u22EC",Ov="\u226E",jv="\u2270",Gv="\u2278",Hv="\u226A\u0338",Zv="\u2A7D\u0338",Fv="\u2274",$v="\u2AA2\u0338",Jv="\u2AA1\u0338",Yv="\u220C",Wv="\u220C",Qv="\u22FE",Kv="\u22FD",Xv="\u2280",eq="\u2AAF\u0338",rq="\u22E0",tq="\u220C",nq="\u29D0\u0338",sq="\u22EB",oq="\u22ED",aq="\u228F\u0338",iq="\u22E2",lq="\u2290\u0338",cq="\u22E3",pq="\u2282\u20D2",uq="\u2288",dq="\u2281",hq="\u2AB0\u0338",mq="\u22E1",gq="\u227F\u0338",fq="\u2283\u20D2",bq="\u2289",_q="\u2241",kq="\u2244",yq="\u2247",xq="\u2249",vq="\u2224",qq="\u2226",Lq="\u2226",wq="\u2AFD\u20E5",Cq="\u2202\u0338",Aq="\u2A14",Sq="\u2280",Eq="\u22E0",Tq="\u2280",Dq="\u2AAF\u0338",Iq="\u2AAF\u0338",zq="\u2933\u0338",Rq="\u219B",Nq="\u21CF",Mq="\u219D\u0338",Pq="\u219B",Vq="\u21CF",Uq="\u22EB",Bq="\u22ED",Oq="\u2281",jq="\u22E1",Gq="\u2AB0\u0338",Hq="\uD835\uDCA9",Zq="\uD835\uDCC3",Fq="\u2224",$q="\u2226",Jq="\u2241",Yq="\u2244",Wq="\u2244",Qq="\u2224",Kq="\u2226",Xq="\u22E2",eL="\u22E3",rL="\u2284",tL="\u2AC5\u0338",nL="\u2288",sL="\u2282\u20D2",oL="\u2288",aL="\u2AC5\u0338",iL="\u2281",lL="\u2AB0\u0338",cL="\u2285",pL="\u2AC6\u0338",uL="\u2289",dL="\u2283\u20D2",hL="\u2289",mL="\u2AC6\u0338",gL="\u2279",fL="\xD1",bL="\xF1",_L="\u2278",kL="\u22EA",yL="\u22EC",xL="\u22EB",vL="\u22ED",qL="\u039D",Nu="\u03BD",nu="#",LL="\u2116",wL="\u2007",CL="\u224D\u20D2",AL="\u22AC",SL="\u22AD",EL="\u22AE",TL="\u22AF",DL="\u2265\u20D2",IL=">\u20D2",zL="\u2904",RL="\u29DE",NL="\u2902",ML="\u2264\u20D2",PL="<\u20D2",VL="\u22B4\u20D2",UL="\u2903",BL="\u22B5\u20D2",OL="\u223C\u20D2",jL="\u2923",GL="\u2196",HL="\u21D6",ZL="\u2196",FL="\u2927",$L="\xD3",JL="\xF3",YL="\u229B",WL="\xD4",QL="\xF4",KL="\u229A",XL="\u041E",ew="\u043E",rw="\u229D",tw="\u0150",nw="\u0151",sw="\u2A38",ow="\u2299",aw="\u29BC",iw="\u0152",lw="\u0153",cw="\u29BF",pw="\uD835\uDD12",uw="\uD835\uDD2C",dw="\u02DB",hw="\xD2",mw="\xF2",gw="\u29C1",fw="\u29B5",bw="\u03A9",_w="\u222E",kw="\u21BA",yw="\u29BE",xw="\u29BB",vw="\u203E",qw="\u29C0",Lw="\u014C",ww="\u014D",Cw="\u03A9",Aw="\u03C9",Sw="\u039F",Ew="\u03BF",Tw="\u29B6",Dw="\u2296",Iw="\uD835\uDD46",zw="\uD835\uDD60",Rw="\u29B7",Nw="\u201C",Mw="\u2018",Pw="\u29B9",Vw="\u2295",Uw="\u21BB",Bw="\u2A54",Or="\u2228",or="\u2A5D",Ow="\u2134",jw="\u2134",Gw="\xAA",Hw="\xBA",Zw="\u22B6",Fw="\u2A56",$w="\u2A57",Jw="\u2A5B",Yw="\u24C8",Ww="\uD835\uDCAA",Qw="\u2134",Kw="\xD8",Xw="\xF8",eC="\u2298",rC="\xD5",tC="\xF5",nC="\u2A36",sC="\u2A37",oC="\u2297",aC="\xD6",iC="\xF6",lC="\u233D",cC="\u203E",pC="\u23DE",uC="\u23B4",dC="\u23DC",hC="\xB6",mC="\u2225",gC="\u2225",fC="\u2AF3",bC="\u2AFD",_C="\u2202",kC="\u2202",yC="\u041F",xC="\u043F",vC="%",qC=".",LC="\u2030",wC="\u22A5",CC="\u2031",AC="\uD835\uDD13",SC="\uD835\uDD2D",EC="\u03A6",TC="\u03C6",DC="\u03D5",IC="\u2133",zC="\u260E",RC="\u03A0",Pi="\u03C0",pi="\u22D4",NC="\u03D6",MC="\u210F",PC="\u210E",VC="\u210F",UC="\u2A23",BC="\u229E",OC="\u2A22",jC="+",GC="\u2214",HC="\u2A25",ZC="\u2A72",FC="\xB1",$C="\xB1",JC="\u2A26",YC="\u2A27",WC="\xB1",pm="\u210C",QC="\u2A15",KC="\uD835\uDD61",XC="\u2119",eA="\xA3",rA="\u2AB7",tA="\u2ABB",Pr="\u227A",pr="\u227C",nA="\u2AB7",sA="\u227A",oA="\u227C",aA="\u227A",iA="\u2AAF",lA="\u227C",cA="\u227E",pA="\u2AAF",uA="\u2AB9",dA="\u2AB5",hA="\u22E8",mA="\u2AAF",gA="\u2AB3",fA="\u227E",bA="\u2032",_A="\u2033",kA="\u2119",yA="\u2AB9",xA="\u2AB5",vA="\u22E8",qA="\u220F",LA="\u220F",wA="\u232E",CA="\u2312",AA="\u2313",SA="\u221D",EA="\u221D",TA="\u2237",DA="\u221D",IA="\u227E",zA="\u22B0",RA="\uD835\uDCAB",NA="\uD835\uDCC5",MA="\u03A8",PA="\u03C8",VA="\u2008",UA="\uD835\uDD14",BA="\uD835\uDD2E",OA="\u2A0C",jA="\uD835\uDD62",GA="\u211A",HA="\u2057",ZA="\uD835\uDCAC",FA="\uD835\uDCC6",$A="\u210D",JA="\u2A16",YA="?",WA="\u225F",QA="\"",KA="\"",XA="\u21DB",eS="\u223D\u0331",rS="\u0154",tS="\u0155",nS="\u221A",sS="\u29B3",oS="\u27E9",aS="\u27EB",iS="\u2992",lS="\u29A5",cS="\u27E9",pS="\xBB",uS="\u2975",dS="\u21E5",hS="\u2920",mS="\u2933",gS="\u2192",fS="\u21A0",bS="\u21D2",_S="\u291E",kS="\u21AA",yS="\u21AC",xS="\u2945",vS="\u2974",qS="\u2916",LS="\u21A3",wS="\u219D",CS="\u291A",AS="\u291C",SS="\u2236",ES="\u211A",TS="\u290D",DS="\u290F",IS="\u2910",zS="\u2773",RS="}",NS="]",MS="\u298C",PS="\u298E",VS="\u2990",US="\u0158",BS="\u0159",OS="\u0156",jS="\u0157",GS="\u2309",HS="}",ZS="\u0420",FS="\u0440",$S="\u2937",JS="\u2969",YS="\u201D",WS="\u201D",QS="\u21B3",KS="\u211C",XS="\u211B",eE="\u211C",rE="\u211D",tE="\u211C",Re="\u25AD",nE="\xAE",sE="\xAE",oE="\u220B",aE="\u21CB",iE="\u296F",lE="\u297D",cE="\u230B",pE="\uD835\uDD2F",uE="\u211C",dE="\u2964",hE="\u21C1",mE="\u21C0",gE="\u296C",fE="\u03A1",bE="\u03C1",_E="\u03F1",kE="\u27E9",yE="\u21E5",xE="\u2192",vE="\u2192",qE="\u21D2",LE="\u21C4",wE="\u21A3",CE="\u2309",AE="\u27E7",SE="\u295D",EE="\u2955",TE="\u21C2",DE="\u230B",IE="\u21C1",zE="\u21C0",RE="\u21C4",NE="\u21CC",ME="\u21C9",PE="\u219D",VE="\u21A6",UE="\u22A2",BE="\u295B",OE="\u22CC",jE="\u29D0",GE="\u22B3",HE="\u22B5",ZE="\u294F",FE="\u295C",$E="\u2954",JE="\u21BE",YE="\u2953",WE="\u21C0",QE="\u02DA",KE="\u2253",XE="\u21C4",eT="\u21CC",rT="\u200F",tT="\u23B1",nT="\u23B1",sT="\u2AEE",oT="\u27ED",aT="\u21FE",iT="\u27E7",lT="\u2986",cT="\uD835\uDD63",pT="\u211D",uT="\u2A2E",dT="\u2A35",hT="\u2970",mT=")",gT="\u2994",fT="\u2A12",bT="\u21C9",_T="\u21DB",kT="\u203A",yT="\uD835\uDCC7",xT="\u211B",vT="\u21B1",qT="\u21B1",LT="]",wT="\u2019",CT="\u2019",AT="\u22CC",ST="\u22CA",ET="\u25B9",TT="\u22B5",DT="\u25B8",IT="\u29CE",zT="\u29F4",RT="\u2968",NT="\u211E",rx="\u015A",MT="\u015B",PT="\u201A",VT="\u2AB8",UT="\u0160",BT="\u0161",OT="\u2ABC",Sc="\u227B",sc="\u227D",jT="\u2AB0",GT="\u2AB4",HT="\u015E",ZT="\u015F",FT="\u015C",$T="\u015D",JT="\u2ABA",YT="\u2AB6",WT="\u22E9",QT="\u2A13",KT="\u227F",XT="\u0421",eD="\u0441",rD="\u22A1",tD="\u22C5",nD="\u2A66",sD="\u2925",oD="\u2198",aD="\u21D8",iD="\u2198",lD="\xA7",cD=";",pD="\u2929",uD="\u2216",dD="\u2216",hD="\u2736",mD="\uD835\uDD16",gD="\uD835\uDD30",fD="\u2322",bD="\u266F",_D="\u0429",kD="\u0449",yD="\u0428",xD="\u0448",vD="\u2193",qD="\u2190",LD="\u2223",wD="\u2225",CD="\u2192",AD="\u2191",SD="\xAD",ED="\u03A3",TD="\u03C3",DD="\u03C2",ID="\u03C2",zD="\u223C",RD="\u2A6A",ND="\u2243",MD="\u2243",PD="\u2A9E",VD="\u2AA0",UD="\u2A9D",BD="\u2A9F",OD="\u2246",jD="\u2A24",GD="\u2972",HD="\u2190",ZD="\u2218",FD="\u2216",$D="\u2A33",JD="\u29E4",YD="\u2223",WD="\u2323",QD="\u2AAA",KD="\u2AAC",XD="\u2AAC\uFE00",eI="\u042C",rI="\u044C",tI="\u233F",nI="\u29C4",sI="/",oI="\uD835\uDD4A",aI="\uD835\uDD64",iI="\u2660",lI="\u2660",cI="\u2225",pI="\u2293",uI="\u2293\uFE00",dI="\u2294",hI="\u2294\uFE00",mI="\u221A",gI="\u228F",fI="\u2291",bI="\u228F",_I="\u2291",kI="\u2290",yI="\u2292",xI="\u2290",vI="\u2292",qI="\u25A1",LI="\u25A1",wI="\u2293",CI="\u228F",AI="\u2291",SI="\u2290",EI="\u2292",TI="\u2294",DI="\u25AA",II="\u25A1",zI="\u25AA",RI="\u2192",NI="\uD835\uDCAE",MI="\uD835\uDCC8",PI="\u2216",VI="\u2323",UI="\u22C6",BI="\u22C6",OI="\u2606",jI="\u2605",GI="\u03F5",HI="\u03D5",ZI="\xAF",FI="\u2282",$I="\u22D0",JI="\u2ABD",YI="\u2AC5",WI="\u2286",QI="\u2AC3",KI="\u2AC1",XI="\u2ACB",ez="\u228A",rz="\u2ABF",tz="\u2979",nz="\u2282",sz="\u22D0",oz="\u2286",az="\u2AC5",iz="\u2286",lz="\u228A",cz="\u2ACB",pz="\u2AC7",uz="\u2AD5",dz="\u2AD3",hz="\u2AB8",mz="\u227B",gz="\u227D",fz="\u227B",bz="\u2AB0",_z="\u227D",kz="\u227F",yz="\u2AB0",xz="\u2ABA",vz="\u2AB6",qz="\u22E9",Lz="\u227F",wz="\u220B",Cz="\u2211",Az="\u2211",Sz="\u266A",Ez="\xB9",Tz="\xB2",Dz="\xB3",Iz="\u2283",zz="\u22D1",Rz="\u2ABE",Nz="\u2AD8",Mz="\u2AC6",Pz="\u2287",Vz="\u2AC4",Uz="\u2283",Bz="\u2287",Oz="\u27C9",jz="\u2AD7",Gz="\u297B",Hz="\u2AC2",Zz="\u2ACC",Fz="\u228B",$z="\u2AC0",Jz="\u2283",Yz="\u22D1",Wz="\u2287",Qz="\u2AC6",Kz="\u228B",Xz="\u2ACC",eR="\u2AC8",rR="\u2AD4",tR="\u2AD6",nR="\u2926",sR="\u2199",oR="\u21D9",aR="\u2199",iR="\u292A",lR="\xDF",cR="\t",pR="\u2316",uR="\u03A4",dR="\u03C4",hR="\u23B4",mR="\u0164",gR="\u0165",fR="\u0162",bR="\u0163",_R="\u0422",kR="\u0442",yR="\u20DB",xR="\u2315",vR="\uD835\uDD17",qR="\uD835\uDD31",LR="\u2234",wR="\u2234",CR="\u2234",AR="\u0398",SR="\u03B8",ER="\u03D1",TR="\u03D1",DR="\u2248",IR="\u223C",zR="\u205F\u200A",RR="\u2009",NR="\u2009",MR="\u2248",PR="\u223C",VR="\xDE",UR="\xFE",BR="\u02DC",OR="\u223C",jR="\u2243",GR="\u2245",HR="\u2248",ZR="\u2A31",FR="\u22A0",$R="\xD7",JR="\u2A30",YR="\u222D",WR="\u2928",QR="\u2336",KR="\u2AF1",XR="\u22A4",eN="\uD835\uDD4B",rN="\uD835\uDD65",tN="\u2ADA",nN="\u2929",sN="\u2034",oN="\u2122",aN="\u2122",iN="\u25B5",lN="\u25BF",cN="\u25C3",pN="\u22B4",uN="\u225C",dN="\u25B9",hN="\u22B5",mN="\u25EC",gN="\u225C",fN="\u2A3A",bN="\u20DB",_N="\u2A39",kN="\u29CD",yN="\u2A3B",xN="\u23E2",vN="\uD835\uDCAF",qN="\uD835\uDCC9",LN="\u0426",wN="\u0446",CN="\u040B",AN="\u045B",SN="\u0166",EN="\u0167",TN="\u226C",DN="\u219E",IN="\u21A0",zN="\xDA",RN="\xFA",NN="\u2191",MN="\u219F",PN="\u21D1",VN="\u2949",UN="\u040E",BN="\u045E",ON="\u016C",jN="\u016D",GN="\xDB",HN="\xFB",ZN="\u0423",FN="\u0443",$N="\u21C5",JN="\u0170",YN="\u0171",WN="\u296E",QN="\u297E",KN="\uD835\uDD18",XN="\uD835\uDD32",eM="\xD9",rM="\xF9",tM="\u2963",nM="\u21BF",sM="\u21BE",oM="\u2580",aM="\u231C",iM="\u231C",lM="\u230F",cM="\u25F8",pM="\u016A",uM="\u016B",dM="\xA8",hM="_",mM="\u23DF",gM="\u23B5",fM="\u23DD",bM="\u22C3",_M="\u228E",kM="\u0172",yM="\u0173",xM="\uD835\uDD4C",vM="\uD835\uDD66",qM="\u2912",LM="\u2191",wM="\u2191",CM="\u21D1",AM="\u21C5",SM="\u2195",EM="\u2195",TM="\u21D5",DM="\u296E",IM="\u21BF",zM="\u21BE",RM="\u228E",NM="\u2196",MM="\u2197",PM="\u03C5",VM="\u03D2",UM="\u03D2",BM="\u03A5",OM="\u03C5",jM="\u21A5",GM="\u22A5",HM="\u21C8",ZM="\u231D",FM="\u231D",$M="\u230E",JM="\u016E",YM="\u016F",WM="\u25F9",QM="\uD835\uDCB0",KM="\uD835\uDCCA",XM="\u22F0",eP="\u0168",rP="\u0169",tP="\u25B5",nP="\u25B4",sP="\u21C8",oP="\xDC",aP="\xFC",iP="\u29A7",lP="\u299C",cP="\u03F5",pP="\u03F0",uP="\u2205",dP="\u03D5",hP="\u03D6",mP="\u221D",gP="\u2195",fP="\u21D5",bP="\u03F1",_P="\u03C2",kP="\u228A\uFE00",yP="\u2ACB\uFE00",xP="\u228B\uFE00",vP="\u2ACC\uFE00",qP="\u03D1",LP="\u22B2",wP="\u22B3",CP="\u2AE8",AP="\u2AEB",SP="\u2AE9",EP="\u0412",TP="\u0432",DP="\u22A2",IP="\u22A8",zP="\u22A9",RP="\u22AB",NP="\u2AE6",MP="\u22BB",PP="\u2228",VP="\u22C1",UP="\u225A",BP="\u22EE",OP="|",jP="\u2016",GP="|",HP="\u2016",ZP="\u2223",FP="|",$P="\u2758",JP="\u2240",YP="\u200A",WP="\uD835\uDD19",QP="\uD835\uDD33",KP="\u22B2",XP="\u2282\u20D2",eV="\u2283\u20D2",rV="\uD835\uDD4D",tV="\uD835\uDD67",nV="\u221D",sV="\u22B3",oV="\uD835\uDCB1",aV="\uD835\uDCCB",iV="\u2ACB\uFE00",lV="\u228A\uFE00",cV="\u2ACC\uFE00",pV="\u228B\uFE00",uV="\u22AA",dV="\u299A",hV="\u0174",mV="\u0175",gV="\u2A5F",fV="\u2227",bV="\u22C0",_V="\u2259",kV="\u2118",yV="\uD835\uDD1A",xV="\uD835\uDD34",vV="\uD835\uDD4E",qV="\uD835\uDD68",LV="\u2118",wp="\u2240",wr="\u2240",wV="\uD835\uDCB2",CV="\uD835\uDCCC",AV="\u22C2",SV="\u25EF",EV="\u22C3",TV="\u25BD",DV="\uD835\uDD1B",IV="\uD835\uDD35",zV="\u27F7",RV="\u27FA",NV="\u039E",Xi="\u03BE",xi="\u27F5",MV="\u27F8",PV="\u27FC",VV="\u22FB",UV="\u2A00",BV="\uD835\uDD4F",OV="\uD835\uDD69",jV="\u2A01",GV="\u2A02",HV="\u27F6",ZV="\u27F9",FV="\uD835\uDCB3",$V="\uD835\uDCCD",JV="\u2A06",YV="\u2A04",WV="\u25B3",QV="\u22C1",KV="\u22C0",XV="\xDD",eU="\xFD",rU="\u042F",tU="\u044F",nU="\u0176",sU="\u0177",oU="\u042B",aU="\u044B",iU="\xA5",lU="\uD835\uDD1C",cU="\uD835\uDD36",pU="\u0407",uU="\u0457",dU="\uD835\uDD50",hU="\uD835\uDD6A",mU="\uD835\uDCB4",gU="\uD835\uDCCE",fU="\u042E",bU="\u044E",_U="\xFF",kU="\u0178",yU="\u0179",xU="\u017A",vU="\u017D",qU="\u017E",LU="\u0417",wU="\u0437",CU="\u017B",AU="\u017C",SU="\u2128",EU="\u200B",TU="\u0396",DU="\u03B6",IU="\uD835\uDD37",zU="\u2128",RU="\u0416",NU="\u0436",MU="\u21DD",PU="\uD835\uDD6B",VU="\u2124",UU="\uD835\uDCB5",BU="\uD835\uDCCF",OU="\u200D",jU="\u200C",GU=/*#__PURE__*/Object.freeze({__proto__:null,Aacute:"\xC1",aacute:Se,Abreve:Ee,abreve:Te,ac:De,acd:Ie,acE:ze,Acirc:Ne,acirc:Me,acute:Pe,Acy:Ve,acy:Ue,AElig:Be,aelig:Oe,af:je,Afr:Ge,afr:He,Agrave:Ze,agrave:Fe,alefsym:$e,aleph:Je,Alpha:Ye,alpha:We,Amacr:Qe,amacr:Ke,amalg:Xe,amp:er,AMP:rr,andand:tr,And:nr,and:sr,andd:ar,andslope:ir,andv:lr,ang:cr,ange:ur,angle:dr,angmsdaa:hr,angmsdab:mr,angmsdac:gr,angmsdad:fr,angmsdae:br,angmsdaf:_r,angmsdag:kr,angmsdah:yr,angmsd:xr,angrt:vr,angrtvb:qr,angrtvbd:Lr,angsph:Cr,angst:Ar,angzarr:Sr,Aogon:Er,aogon:Tr,Aopf:Dr,aopf:Ir,apacir:zr,ap:Rr,apE:Nr,ape:Mr,apid:Vr,apos:Ur,ApplyFunction:Br,approx:jr,approxeq:Gr,Aring:Hr,aring:Zr,Ascr:Fr,ascr:$r,Assign:Jr,ast:Yr,asymp:Wr,asympeq:Qr,Atilde:Kr,atilde:Xr,Auml:et,auml:rt,awconint:tt,awint:nt,backcong:st,backepsilon:ot,backprime:at,backsim:ct,backsimeq:pt,Backslash:ut,Barv:dt,barvee:ht,barwed:mt,Barwed:ft,barwedge:bt,bbrk:_t,bbrktbrk:kt,bcong:yt,Bcy:xt,bcy:vt,bdquo:qt,becaus:wt,because:Ct,Because:At,bemptyv:St,bepsi:Et,bernou:Tt,Bernoullis:Dt,Beta:It,beta:zt,beth:Rt,between:Nt,Bfr:Mt,bfr:Pt,bigcap:Vt,bigcirc:Ut,bigcup:Bt,bigodot:Ot,bigoplus:jt,bigotimes:Ht,bigsqcup:Zt,bigstar:Ft,bigtriangledown:$t,bigtriangleup:Jt,biguplus:Yt,bigvee:Wt,bigwedge:Qt,bkarow:Kt,blacklozenge:Xt,blacksquare:en,blacktriangle:rn,blacktriangledown:tn,blacktriangleleft:nn,blacktriangleright:sn,blank:on,blk12:an,blk14:ln,blk34:cn,block:pn,bne:un,bnequiv:dn,bNot:hn,bnot:mn,Bopf:gn,bopf:fn,bot:bn,bottom:_n,bowtie:kn,boxbox:yn,boxdl:xn,boxdL:vn,boxDl:qn,boxDL:Ln,boxdr:wn,boxdR:Cn,boxDr:An,boxDR:Sn,boxh:En,boxH:Tn,boxhd:Dn,boxHd:In,boxhD:zn,boxHD:Rn,boxhu:Nn,boxHu:Mn,boxhU:Pn,boxHU:Vn,boxminus:Un,boxplus:Bn,boxtimes:On,boxul:jn,boxuL:Gn,boxUl:Hn,boxUL:Zn,boxur:Fn,boxuR:$n,boxUr:Jn,boxUR:Yn,boxv:Wn,boxV:Qn,boxvh:Kn,boxvH:Xn,boxVh:es,boxVH:rs,boxvl:ts,boxvL:ns,boxVl:ss,boxVL:os,boxvr:as,boxvR:is,boxVr:ls,boxVR:cs,bprime:ps,breve:us,Breve:ds,brvbar:hs,bscr:ms,Bscr:gs,bsemi:fs,bsim:bs,bsime:_s,bsolb:ks,bsol:ys,bsolhsub:xs,bull:vs,bullet:qs,bump:Ls,bumpE:ws,bumpe:Cs,Bumpeq:As,bumpeq:Ss,Cacute:Es,cacute:Ts,capand:Ds,capbrcup:Is,capcap:zs,cap:Rs,Cap:Ns,capcup:Ms,capdot:Ps,CapitalDifferentialD:Vs,caps:Us,caret:Bs,caron:Os,Cayleys:js,ccaps:Gs,Ccaron:Hs,ccaron:Zs,Ccedil:Fs,ccedil:$s,Ccirc:Js,ccirc:Ys,Cconint:Ws,ccups:Qs,ccupssm:Ks,Cdot:Xs,cdot:eo,cedil:ro,Cedilla:to,cemptyv:no,cent:so,centerdot:oo,CenterDot:ao,cfr:io,Cfr:lo,CHcy:co,chcy:po,check:uo,checkmark:ho,Chi:mo,chi:go,circ:fo,circeq:bo,circlearrowleft:_o,circlearrowright:ko,circledast:yo,circledcirc:xo,circleddash:vo,CircleDot:qo,circledR:Lo,circledS:wo,CircleMinus:Co,CirclePlus:Ao,CircleTimes:So,cir:Eo,cirE:To,cire:Do,cirfnint:Io,cirmid:zo,cirscir:Ro,ClockwiseContourIntegral:No,CloseCurlyDoubleQuote:Mo,CloseCurlyQuote:Po,clubs:Vo,clubsuit:Uo,colon:Bo,Colon:Oo,Colone:jo,colone:Go,coloneq:Ho,comma:Zo,commat:Fo,comp:$o,compfn:Jo,complement:Yo,complexes:Wo,cong:Qo,congdot:Ko,Congruent:Xo,conint:ea,Conint:ra,ContourIntegral:ta,copf:na,Copf:sa,coprod:oa,Coproduct:aa,copy:ia,COPY:la,copysr:ca,CounterClockwiseContourIntegral:pa,crarr:ua,cross:da,Cross:ha,Cscr:ma,cscr:ga,csub:fa,csube:ba,csup:_a,csupe:ka,ctdot:ya,cudarrl:xa,cudarrr:va,cuepr:qa,cuesc:La,cularr:wa,cularrp:Ca,cupbrcap:Aa,cupcap:Sa,CupCap:Ea,cup:Ta,Cup:Da,cupcup:Ia,cupdot:za,cupor:Ra,cups:Na,curarr:Ma,curarrm:Pa,curlyeqprec:Va,curlyeqsucc:Ua,curlyvee:Ba,curlywedge:Oa,curren:ja,curvearrowleft:Ga,curvearrowright:Ha,cuvee:Za,cuwed:Fa,cwconint:$a,cwint:Ja,cylcty:Ya,dagger:Wa,Dagger:Qa,daleth:Ka,darr:Xa,Darr:ei,dArr:ri,dash:ti,Dashv:si,dashv:oi,dbkarow:ai,dblac:li,Dcaron:ci,dcaron:ui,Dcy:di,dcy:hi,ddagger:mi,ddarr:gi,DD:fi,dd:bi,DDotrahd:_i,ddotseq:ki,deg:yi,Del:vi,Delta:qi,delta:Li,demptyv:wi,dfisht:Ci,Dfr:Ai,dfr:Si,dHar:Ei,dharl:Ti,dharr:Di,DiacriticalAcute:Ii,DiacriticalDot:zi,DiacriticalDoubleAcute:Ri,DiacriticalGrave:Ni,DiacriticalTilde:Mi,diam:Vi,diamond:Ui,Diamond:Bi,diamondsuit:Oi,diams:ji,die:Gi,DifferentialD:Hi,digamma:Zi,disin:Fi,div:$i,divide:Ji,divideontimes:Yi,divonx:Wi,DJcy:Qi,djcy:Ki,dlcorn:rl,dlcrop:tl,dollar:nl,Dopf:sl,dopf:ol,Dot:al,dot:il,DotDot:cl,doteq:pl,doteqdot:ul,DotEqual:dl,dotminus:hl,dotplus:ml,dotsquare:fl,doublebarwedge:bl,DoubleContourIntegral:_l,DoubleDot:kl,DoubleDownArrow:yl,DoubleLeftArrow:xl,DoubleLeftRightArrow:vl,DoubleLeftTee:ql,DoubleLongLeftArrow:wl,DoubleLongLeftRightArrow:Cl,DoubleLongRightArrow:Al,DoubleRightArrow:Sl,DoubleRightTee:El,DoubleUpArrow:Tl,DoubleUpDownArrow:Dl,DoubleVerticalBar:Il,DownArrowBar:zl,downarrow:Rl,DownArrow:Nl,Downarrow:Ml,DownArrowUpArrow:Pl,DownBreve:Vl,downdownarrows:Ul,downharpoonleft:Bl,downharpoonright:Ol,DownLeftRightVector:jl,DownLeftTeeVector:Gl,DownLeftVectorBar:Hl,DownLeftVector:Zl,DownRightTeeVector:Fl,DownRightVectorBar:$l,DownRightVector:Jl,DownTeeArrow:Yl,DownTee:Wl,drbkarow:Ql,drcorn:Kl,drcrop:Xl,Dscr:ec,dscr:rc,DScy:tc,dscy:nc,dsol:oc,Dstrok:ac,dstrok:lc,dtdot:cc,dtri:pc,dtrif:uc,duarr:dc,duhar:hc,dwangle:mc,DZcy:gc,dzcy:fc,dzigrarr:bc,Eacute:_c,eacute:kc,easter:yc,Ecaron:xc,ecaron:vc,Ecirc:qc,ecirc:Lc,ecir:wc,ecolon:Cc,Ecy:Ac,ecy:Ec,eDDot:Tc,Edot:Dc,edot:Ic,eDot:zc,ee:Rc,efDot:ee,Efr:Nc,efr:Mc,eg:Pc,Egrave:Vc,egrave:Uc,egs:Bc,egsdot:Oc,el:jc,Element:el,elinters:Gc,ell:Hc,els:Zc,elsdot:Fc,Emacr:$c,emacr:Jc,empty:Yc,emptyset:Wc,EmptySmallSquare:Qc,emptyv:Kc,EmptyVerySmallSquare:Xc,emsp13:ep,emsp14:rp,emsp:tp,ENG:np,eng:sp,ensp:op,Eogon:ap,eogon:ip,Eopf:lp,eopf:cp,epar:pp,eparsl:up,eplus:dp,epsi:hp,Epsilon:gp,epsilon:fp,epsiv:bp,eqcirc:_p,eqcolon:kp,eqsim:yp,eqslantgtr:xp,eqslantless:vp,Equal:qp,equals:Lp,EqualTilde:Cp,equest:Ap,Equilibrium:Sp,equiv:Ep,equivDD:Tp,eqvparsl:Dp,erarr:Ip,erDot:zp,escr:Rp,Escr:Np,esdot:Mp,Esim:Pp,esim:Vp,Eta:Up,eta:Bp,ETH:Op,eth:jp,Euml:Gp,euml:Hp,euro:Zp,excl:Fp,exist:$p,Exists:Jp,expectation:Yp,exponentiale:Wp,ExponentialE:Qp,fallingdotseq:Kp,Fcy:Xp,fcy:eu,female:ru,ffilig:tu,fflig:su,ffllig:ou,Ffr:au,ffr:iu,filig:lu,FilledSmallSquare:cu,FilledVerySmallSquare:pu,fjlig:uu,flat:du,fllig:hu,fltns:gu,fnof:fu,Fopf:bu,fopf:_u,forall:ku,ForAll:yu,fork:xu,forkv:vu,Fouriertrf:qu,fpartint:Lu,frac12:wu,frac13:Cu,frac14:Au,frac15:Su,frac16:Eu,frac18:Tu,frac23:Du,frac25:Iu,frac34:zu,frac35:Ru,frac38:Pu,frac45:Vu,frac56:Uu,frac58:Bu,frac78:Ou,frasl:ju,frown:Gu,fscr:Hu,Fscr:Zu,gacute:Fu,Gamma:$u,gamma:Ju,Gammad:Yu,gammad:Wu,gap:Qu,Gbreve:Ku,gbreve:Xu,Gcedil:ed,Gcirc:rd,gcirc:td,Gcy:nd,gcy:sd,Gdot:od,gdot:ad,ge:id,gE:ge,gEl:ld,gel:cd,geq:pd,geqq:ud,geqslant:dd,gescc:hd,ges:md,gesdot:gd,gesdoto:fd,gesdotol:bd,gesl:_d,gesles:kd,Gfr:yd,gfr:xd,gg:vd,Gg:qd,ggg:Ld,gimel:wd,GJcy:Cd,gjcy:Ad,gla:Sd,gl:Ed,glE:gl,glj:Td,gnap:Dd,gnapprox:Id,gne:zd,gnE:Rd,gneq:Nd,gneqq:Md,gnsim:Pd,Gopf:Vd,gopf:Ud,grave:Bd,GreaterEqual:Od,GreaterEqualLess:jd,GreaterFullEqual:Gd,GreaterGreater:Hd,GreaterLess:Zd,GreaterSlantEqual:Fd,GreaterTilde:$d,Gscr:Jd,gscr:Yd,gsim:Wd,gsime:Qd,gsiml:Kd,gtcc:Xd,gtcir:eh,gt:rh,GT:gt,Gt:th,gtdot:Gt,gtlPar:nh,gtquest:sh,gtrapprox:oh,gtrarr:ah,gtrdot:ih,gtreqless:lh,gtreqqless:ch,gtrless:ph,gtrsim:uh,gvertneqq:dh,gvnE:hh,Hacek:mh,hairsp:gh,half:fh,hamilt:bh,HARDcy:_h,hardcy:kh,harrcir:yh,harr:xh,hArr:vh,harrw:qh,Hat:Lh,hbar:wh,Hcirc:Ch,hcirc:Ah,hearts:Sh,heartsuit:Eh,hellip:Th,hercon:Dh,hfr:Ih,Hfr:zh,HilbertSpace:Rh,hksearow:Nh,hkswarow:Mh,hoarr:Ph,homtht:Vh,hookleftarrow:Uh,hookrightarrow:Bh,hopf:Oh,Hopf:jh,horbar:Gh,HorizontalLine:Hh,hscr:Zh,Hscr:Fh,hslash:$h,Hstrok:Jh,hstrok:Yh,HumpDownHump:Wh,HumpEqual:Qh,hybull:Kh,hyphen:Xh,Iacute:em,iacute:rm,ic:tm,Icirc:ic,icirc:nm,Icy:sm,icy:om,Idot:am,IEcy:im,iecy:lm,iexcl:cm,iff:um,ifr:dm,Ifr:hm,Igrave:mm,igrave:gm,ii:fm,iiiint:ii,iiint:bm,iinfin:_m,iiota:km,IJlig:ym,ijlig:xm,Imacr:vm,imacr:qm,image:Lm,ImaginaryI:wm,imagline:Cm,imagpart:Am,imath:Sm,Im:Em,imof:Tm,imped:Dm,Implies:Im,incare:zm,infin:Rm,infintie:Nm,inodot:Mm,intcal:Pm,int:Vm,Int:Um,integers:Bm,Integral:Om,intercal:jm,Intersection:Gm,intlarhk:Hm,intprod:Zm,InvisibleComma:Fm,InvisibleTimes:$m,IOcy:Jm,iocy:Ym,Iogon:Wm,iogon:Qm,Iopf:Km,iopf:Xm,Iota:eg,iota:rg,iprod:tg,iquest:ng,iscr:sg,Iscr:og,isin:ag,isindot:ig,isinE:cg,isins:pg,isinsv:ug,isinv:dg,it:hg,Itilde:it,itilde:mg,Iukcy:gg,iukcy:fg,Iuml:bg,iuml:_g,Jcirc:kg,jcirc:yg,Jcy:xg,jcy:vg,Jfr:qg,jfr:Lg,jmath:wg,Jopf:Cg,jopf:Ag,Jscr:Sg,jscr:Eg,Jsercy:Tg,jsercy:Dg,Jukcy:Ig,jukcy:zg,Kappa:Rg,kappa:Ng,kappav:Mg,Kcedil:Pg,kcedil:Vg,Kcy:Ug,kcy:Bg,Kfr:Og,kfr:jg,kgreen:Gg,KHcy:Hg,khcy:Zg,KJcy:Fg,kjcy:$g,Kopf:Jg,kopf:Yg,Kscr:Wg,kscr:Qg,lAarr:Kg,Lacute:Xg,lacute:ef,laemptyv:rf,lagran:tf,Lambda:nf,lambda:sf,lang:of,Lang:af,langd:lf,langle:cf,lap:pf,Laplacetrf:uf,laquo:df,larrb:hf,larrbfs:mf,larr:gf,Larr:ff,lArr:bf,larrfs:_f,larrhk:kf,larrlp:yf,larrpl:xf,larrsim:vf,larrtl:qf,latail:Lf,lAtail:wf,lat:Cf,late:Af,lates:Sf,lbarr:Ef,lBarr:Tf,lbbrk:Df,lbrace:If,lbrack:zf,lbrke:Rf,lbrksld:Nf,lbrkslu:Mf,Lcaron:Pf,lcaron:Vf,Lcedil:Uf,lcedil:Bf,lceil:Of,lcub:jf,Lcy:Gf,lcy:Hf,ldca:Zf,ldquo:Ff,ldquor:$f,ldrdhar:Jf,ldrushar:Yf,ldsh:Wf,le:Qf,lE:le,LeftAngleBracket:Kf,LeftArrowBar:Xf,leftarrow:eb,LeftArrow:rb,Leftarrow:tb,LeftArrowRightArrow:nb,leftarrowtail:sb,LeftCeiling:ob,LeftDoubleBracket:ab,LeftDownTeeVector:ib,LeftDownVectorBar:lb,LeftDownVector:cb,LeftFloor:pb,leftharpoondown:ub,leftharpoonup:db,leftleftarrows:hb,leftrightarrow:mb,LeftRightArrow:gb,Leftrightarrow:fb,leftrightarrows:bb,leftrightharpoons:_b,leftrightsquigarrow:kb,LeftRightVector:yb,LeftTeeArrow:xb,LeftTee:vb,LeftTeeVector:qb,leftthreetimes:Lb,LeftTriangleBar:wb,LeftTriangle:Cb,LeftTriangleEqual:Ab,LeftUpDownVector:Sb,LeftUpTeeVector:Eb,LeftUpVectorBar:Tb,LeftUpVector:Db,LeftVectorBar:Ib,LeftVector:zb,lEg:Rb,leg:Nb,leq:Mb,leqq:Pb,leqslant:Vb,lescc:Ub,les:Bb,lesdot:Ob,lesdoto:jb,lesdotor:Gb,lesg:Hb,lesges:Zb,lessapprox:Fb,lessdot:$b,lesseqgtr:Jb,lesseqqgtr:Yb,LessEqualGreater:Wb,LessFullEqual:Qb,LessGreater:Kb,lessgtr:Xb,LessLess:e_,lesssim:r_,LessSlantEqual:t_,LessTilde:n_,lfisht:s_,lfloor:o_,Lfr:a_,lfr:i_,lg:l_,lgE:lg,lHar:c_,lhard:p_,lharu:u_,lharul:d_,lhblk:h_,LJcy:m_,ljcy:g_,llarr:f_,ll:b_,Ll:ll,llcorner:Ll,Lleftarrow:__,llhard:k_,lltri:y_,Lmidot:x_,lmidot:v_,lmoustache:q_,lmoust:L_,lnap:w_,lnapprox:C_,lne:A_,lnE:S_,lneq:E_,lneqq:T_,lnsim:D_,loang:I_,loarr:z_,lobrk:R_,longleftarrow:N_,LongLeftArrow:M_,Longleftarrow:P_,longleftrightarrow:V_,LongLeftRightArrow:U_,Longleftrightarrow:B_,longmapsto:O_,longrightarrow:j_,LongRightArrow:G_,Longrightarrow:H_,looparrowleft:Z_,looparrowright:F_,lopar:$_,Lopf:J_,lopf:Y_,loplus:W_,lotimes:Q_,lowast:K_,lowbar:X_,LowerLeftArrow:ek,LowerRightArrow:rk,loz:tk,lozenge:nk,lozf:sk,lpar:ok,lparlt:ak,lrarr:ik,lrcorner:lk,lrhar:ck,lrhard:pk,lrm:uk,lrtri:dk,lsaquo:hk,lscr:mk,Lscr:gk,lsh:fk,Lsh:bk,lsim:_k,lsime:kk,lsimg:yk,lsqb:xk,lsquo:vk,lsquor:qk,Lstrok:Lk,lstrok:wk,ltcc:Ck,ltcir:Ak,lt:Sk,LT:lt,Lt:Ek,ltdot:Lt,lthree:Tk,ltimes:Dk,ltlarr:Ik,ltquest:zk,ltri:Rk,ltrie:Nk,ltrif:Mk,ltrPar:Pk,lurdshar:Vk,luruhar:Uk,lvertneqq:Bk,lvnE:Ok,macr:jk,male:Gk,malt:Hk,maltese:Zk,map:Fk,mapsto:$k,mapstodown:Jk,mapstoleft:Yk,mapstoup:Wk,marker:Qk,mcomma:Kk,Mcy:Xk,mcy:ey,mdash:ry,mDDot:ty,measuredangle:ny,MediumSpace:sy,Mellintrf:oy,Mfr:ay,mfr:iy,mho:ly,micro:cy,midast:py,midcir:uy,mid:dy,middot:hy,minusb:my,minus:gy,minusd:fy,minusdu:by,MinusPlus:_y,mlcp:ky,mldr:yy,mnplus:xy,models:vy,Mopf:qy,mopf:Ly,mp:wy,mscr:mp,Mscr:Cy,mstpos:Ay,Mu:Sy,mu:Mu,multimap:mu,mumap:Ey,nabla:Ty,Nacute:Dy,nacute:Iy,nang:zy,nap:Ry,napE:Ny,napid:My,napos:Py,napprox:Vy,natural:Uy,naturals:By,natur:Oy,nbsp:jy,nbump:Gy,nbumpe:Hy,ncap:Zy,Ncaron:Fy,ncaron:$y,Ncedil:Jy,ncedil:Yy,ncong:Wy,ncongdot:Qy,ncup:Ky,Ncy:Xy,ncy:ex,ndash:tx,nearhk:nx,nearr:sx,neArr:ox,nearrow:ax,ne:ix,nedot:ne,NegativeMediumSpace:lx,NegativeThickSpace:cx,NegativeThinSpace:px,NegativeVeryThinSpace:ux,nequiv:dx,nesear:hx,nesim:mx,NestedGreaterGreater:gx,NestedLessLess:fx,NewLine:bx,nexist:_x,nexists:kx,Nfr:yx,nfr:xx,ngE:vx,nge:qx,ngeq:Lx,ngeqq:wx,ngeqslant:Cx,nges:Ax,nGg:Sx,ngsim:Ex,nGt:Tx,ngt:Dx,ngtr:Ix,nGtv:zx,nharr:Rx,nhArr:Nx,nhpar:Mx,ni:Px,nis:ni,nisd:Vx,niv:Ux,NJcy:Bx,njcy:Ox,nlarr:jx,nlArr:Gx,nldr:Hx,nlE:Zx,nle:Fx,nleftarrow:$x,nLeftarrow:Jx,nleftrightarrow:Yx,nLeftrightarrow:Wx,nleq:Qx,nleqq:Kx,nleqslant:Xx,nles:ev,nless:rv,nLl:tv,nlsim:nv,nLt:sv,nlt:ov,nltri:av,nltrie:iv,nLtv:lv,nmid:cv,NoBreak:pv,NonBreakingSpace:uv,nopf:dv,Nopf:hv,Not:mv,not:gv,NotCongruent:fv,NotCupCap:bv,NotDoubleVerticalBar:_v,NotElement:kv,NotEqual:yv,NotEqualTilde:xv,NotExists:vv,NotGreater:qv,NotGreaterEqual:Lv,NotGreaterFullEqual:wv,NotGreaterGreater:Cv,NotGreaterLess:Av,NotGreaterSlantEqual:Sv,NotGreaterTilde:Ev,NotHumpDownHump:Tv,NotHumpEqual:Dv,notin:Iv,notindot:zv,notinE:Rv,notinva:Nv,notinvb:Mv,notinvc:Pv,NotLeftTriangleBar:Vv,NotLeftTriangle:Uv,NotLeftTriangleEqual:Bv,NotLess:Ov,NotLessEqual:jv,NotLessGreater:Gv,NotLessLess:Hv,NotLessSlantEqual:Zv,NotLessTilde:Fv,NotNestedGreaterGreater:$v,NotNestedLessLess:Jv,notni:Yv,notniva:Wv,notnivb:Qv,notnivc:Kv,NotPrecedes:Xv,NotPrecedesEqual:eq,NotPrecedesSlantEqual:rq,NotReverseElement:tq,NotRightTriangleBar:nq,NotRightTriangle:sq,NotRightTriangleEqual:oq,NotSquareSubset:aq,NotSquareSubsetEqual:iq,NotSquareSuperset:lq,NotSquareSupersetEqual:cq,NotSubset:pq,NotSubsetEqual:uq,NotSucceeds:dq,NotSucceedsEqual:hq,NotSucceedsSlantEqual:mq,NotSucceedsTilde:gq,NotSuperset:fq,NotSupersetEqual:bq,NotTilde:_q,NotTildeEqual:kq,NotTildeFullEqual:yq,NotTildeTilde:xq,NotVerticalBar:vq,nparallel:qq,npar:Lq,nparsl:wq,npart:Cq,npolint:Aq,npr:Sq,nprcue:Eq,nprec:Tq,npreceq:Dq,npre:Iq,nrarrc:zq,nrarr:Rq,nrArr:Nq,nrarrw:Mq,nrightarrow:Pq,nRightarrow:Vq,nrtri:Uq,nrtrie:Bq,nsc:Oq,nsccue:jq,nsce:Gq,Nscr:Hq,nscr:Zq,nshortmid:Fq,nshortparallel:$q,nsim:Jq,nsime:Yq,nsimeq:Wq,nsmid:Qq,nspar:Kq,nsqsube:Xq,nsqsupe:eL,nsub:rL,nsubE:tL,nsube:nL,nsubset:sL,nsubseteq:oL,nsubseteqq:aL,nsucc:iL,nsucceq:lL,nsup:cL,nsupE:pL,nsupe:uL,nsupset:dL,nsupseteq:hL,nsupseteqq:mL,ntgl:gL,Ntilde:fL,ntilde:bL,ntlg:_L,ntriangleleft:kL,ntrianglelefteq:yL,ntriangleright:xL,ntrianglerighteq:vL,Nu:qL,nu:Nu,num:nu,numero:LL,numsp:wL,nvap:CL,nvdash:AL,nvDash:SL,nVdash:EL,nVDash:TL,nvge:DL,nvgt:IL,nvHarr:zL,nvinfin:RL,nvlArr:NL,nvle:ML,nvlt:PL,nvltrie:VL,nvrArr:UL,nvrtrie:BL,nvsim:OL,nwarhk:jL,nwarr:GL,nwArr:HL,nwarrow:ZL,nwnear:FL,Oacute:$L,oacute:JL,oast:YL,Ocirc:WL,ocirc:QL,ocir:KL,Ocy:XL,ocy:ew,odash:rw,Odblac:tw,odblac:nw,odiv:sw,odot:ow,odsold:aw,OElig:iw,oelig:lw,ofcir:cw,Ofr:pw,ofr:uw,ogon:dw,Ograve:hw,ograve:mw,ogt:gw,ohbar:fw,ohm:bw,oint:_w,olarr:kw,olcir:yw,olcross:xw,oline:vw,olt:qw,Omacr:Lw,omacr:ww,Omega:Cw,omega:Aw,Omicron:Sw,omicron:Ew,omid:Tw,ominus:Dw,Oopf:Iw,oopf:zw,opar:Rw,OpenCurlyDoubleQuote:Nw,OpenCurlyQuote:Mw,operp:Pw,oplus:Vw,orarr:Uw,Or:Bw,or:Or,ord:or,order:Ow,orderof:jw,ordf:Gw,ordm:Hw,origof:Zw,oror:Fw,orslope:$w,orv:Jw,oS:Yw,Oscr:Ww,oscr:Qw,Oslash:Kw,oslash:Xw,osol:eC,Otilde:rC,otilde:tC,otimesas:nC,Otimes:sC,otimes:oC,Ouml:aC,ouml:iC,ovbar:lC,OverBar:cC,OverBrace:pC,OverBracket:uC,OverParenthesis:dC,para:hC,parallel:mC,par:gC,parsim:fC,parsl:bC,part:_C,PartialD:kC,Pcy:yC,pcy:xC,percnt:vC,period:qC,permil:LC,perp:wC,pertenk:CC,Pfr:AC,pfr:SC,Phi:EC,phi:TC,phiv:DC,phmmat:IC,phone:zC,Pi:RC,pi:Pi,pitchfork:pi,piv:NC,planck:MC,planckh:PC,plankv:VC,plusacir:UC,plusb:BC,pluscir:OC,plus:jC,plusdo:GC,plusdu:HC,pluse:ZC,PlusMinus:FC,plusmn:$C,plussim:JC,plustwo:YC,pm:WC,Poincareplane:pm,pointint:QC,popf:KC,Popf:XC,pound:eA,prap:rA,Pr:tA,pr:Pr,prcue:pr,precapprox:nA,prec:sA,preccurlyeq:oA,Precedes:aA,PrecedesEqual:iA,PrecedesSlantEqual:lA,PrecedesTilde:cA,preceq:pA,precnapprox:uA,precneqq:dA,precnsim:hA,pre:mA,prE:gA,precsim:fA,prime:bA,Prime:_A,primes:kA,prnap:yA,prnE:xA,prnsim:vA,prod:qA,Product:LA,profalar:wA,profline:CA,profsurf:AA,prop:SA,Proportional:EA,Proportion:TA,propto:DA,prsim:IA,prurel:zA,Pscr:RA,pscr:NA,Psi:MA,psi:PA,puncsp:VA,Qfr:UA,qfr:BA,qint:OA,qopf:jA,Qopf:GA,qprime:HA,Qscr:ZA,qscr:FA,quaternions:$A,quatint:JA,quest:YA,questeq:WA,quot:QA,QUOT:KA,rAarr:XA,race:eS,Racute:rS,racute:tS,radic:nS,raemptyv:sS,rang:oS,Rang:aS,rangd:iS,range:lS,rangle:cS,raquo:pS,rarrap:uS,rarrb:dS,rarrbfs:hS,rarrc:mS,rarr:gS,Rarr:fS,rArr:bS,rarrfs:_S,rarrhk:kS,rarrlp:yS,rarrpl:xS,rarrsim:vS,Rarrtl:qS,rarrtl:LS,rarrw:wS,ratail:CS,rAtail:AS,ratio:SS,rationals:ES,rbarr:TS,rBarr:DS,RBarr:IS,rbbrk:zS,rbrace:RS,rbrack:NS,rbrke:MS,rbrksld:PS,rbrkslu:VS,Rcaron:US,rcaron:BS,Rcedil:OS,rcedil:jS,rceil:GS,rcub:HS,Rcy:ZS,rcy:FS,rdca:$S,rdldhar:JS,rdquo:YS,rdquor:WS,rdsh:QS,real:KS,realine:XS,realpart:eE,reals:rE,Re:tE,rect:Re,reg:nE,REG:sE,ReverseElement:oE,ReverseEquilibrium:aE,ReverseUpEquilibrium:iE,rfisht:lE,rfloor:cE,rfr:pE,Rfr:uE,rHar:dE,rhard:hE,rharu:mE,rharul:gE,Rho:fE,rho:bE,rhov:_E,RightAngleBracket:kE,RightArrowBar:yE,rightarrow:xE,RightArrow:vE,Rightarrow:qE,RightArrowLeftArrow:LE,rightarrowtail:wE,RightCeiling:CE,RightDoubleBracket:AE,RightDownTeeVector:SE,RightDownVectorBar:EE,RightDownVector:TE,RightFloor:DE,rightharpoondown:IE,rightharpoonup:zE,rightleftarrows:RE,rightleftharpoons:NE,rightrightarrows:ME,rightsquigarrow:PE,RightTeeArrow:VE,RightTee:UE,RightTeeVector:BE,rightthreetimes:OE,RightTriangleBar:jE,RightTriangle:GE,RightTriangleEqual:HE,RightUpDownVector:ZE,RightUpTeeVector:FE,RightUpVectorBar:$E,RightUpVector:JE,RightVectorBar:YE,RightVector:WE,ring:QE,risingdotseq:KE,rlarr:XE,rlhar:eT,rlm:rT,rmoustache:tT,rmoust:nT,rnmid:sT,roang:oT,roarr:aT,robrk:iT,ropar:lT,ropf:cT,Ropf:pT,roplus:uT,rotimes:dT,RoundImplies:hT,rpar:mT,rpargt:gT,rppolint:fT,rrarr:bT,Rrightarrow:_T,rsaquo:kT,rscr:yT,Rscr:xT,rsh:vT,Rsh:qT,rsqb:LT,rsquo:wT,rsquor:CT,rthree:AT,rtimes:ST,rtri:ET,rtrie:TT,rtrif:DT,rtriltri:IT,RuleDelayed:zT,ruluhar:RT,rx:NT,Sacute:rx,sacute:MT,sbquo:PT,scap:VT,Scaron:UT,scaron:BT,Sc:OT,sc:Sc,sccue:sc,sce:jT,scE:GT,Scedil:HT,scedil:ZT,Scirc:FT,scirc:$T,scnap:JT,scnE:YT,scnsim:WT,scpolint:QT,scsim:KT,Scy:XT,scy:eD,sdotb:rD,sdot:tD,sdote:nD,searhk:sD,searr:oD,seArr:aD,searrow:iD,sect:lD,semi:cD,seswar:pD,setminus:uD,setmn:dD,sext:hD,Sfr:mD,sfr:gD,sfrown:fD,sharp:bD,SHCHcy:_D,shchcy:kD,SHcy:yD,shcy:xD,ShortDownArrow:vD,ShortLeftArrow:qD,shortmid:LD,shortparallel:wD,ShortRightArrow:CD,ShortUpArrow:AD,shy:SD,Sigma:ED,sigma:TD,sigmaf:DD,sigmav:ID,sim:zD,simdot:RD,sime:ND,simeq:MD,simg:PD,simgE:VD,siml:UD,simlE:BD,simne:OD,simplus:jD,simrarr:GD,slarr:HD,SmallCircle:ZD,smallsetminus:FD,smashp:$D,smeparsl:JD,smid:YD,smile:WD,smt:QD,smte:KD,smtes:XD,SOFTcy:eI,softcy:rI,solbar:tI,solb:nI,sol:sI,Sopf:oI,sopf:aI,spades:iI,spadesuit:lI,spar:cI,sqcap:pI,sqcaps:uI,sqcup:dI,sqcups:hI,Sqrt:mI,sqsub:gI,sqsube:fI,sqsubset:bI,sqsubseteq:_I,sqsup:kI,sqsupe:yI,sqsupset:xI,sqsupseteq:vI,square:qI,Square:LI,SquareIntersection:wI,SquareSubset:CI,SquareSubsetEqual:AI,SquareSuperset:SI,SquareSupersetEqual:EI,SquareUnion:TI,squarf:DI,squ:II,squf:zI,srarr:RI,Sscr:NI,sscr:MI,ssetmn:PI,ssmile:VI,sstarf:UI,Star:BI,star:OI,starf:jI,straightepsilon:GI,straightphi:HI,strns:ZI,sub:FI,Sub:$I,subdot:JI,subE:YI,sube:WI,subedot:QI,submult:KI,subnE:XI,subne:ez,subplus:rz,subrarr:tz,subset:nz,Subset:sz,subseteq:oz,subseteqq:az,SubsetEqual:iz,subsetneq:lz,subsetneqq:cz,subsim:pz,subsub:uz,subsup:dz,succapprox:hz,succ:mz,succcurlyeq:gz,Succeeds:fz,SucceedsEqual:bz,SucceedsSlantEqual:_z,SucceedsTilde:kz,succeq:yz,succnapprox:xz,succneqq:vz,succnsim:qz,succsim:Lz,SuchThat:wz,sum:Cz,Sum:Az,sung:Sz,sup1:Ez,sup2:Tz,sup3:Dz,sup:Iz,Sup:zz,supdot:Rz,supdsub:Nz,supE:Mz,supe:Pz,supedot:Vz,Superset:Uz,SupersetEqual:Bz,suphsol:Oz,suphsub:jz,suplarr:Gz,supmult:Hz,supnE:Zz,supne:Fz,supplus:$z,supset:Jz,Supset:Yz,supseteq:Wz,supseteqq:Qz,supsetneq:Kz,supsetneqq:Xz,supsim:eR,supsub:rR,supsup:tR,swarhk:nR,swarr:sR,swArr:oR,swarrow:aR,swnwar:iR,szlig:lR,Tab:cR,target:pR,Tau:uR,tau:dR,tbrk:hR,Tcaron:mR,tcaron:gR,Tcedil:fR,tcedil:bR,Tcy:_R,tcy:kR,tdot:yR,telrec:xR,Tfr:vR,tfr:qR,there4:LR,therefore:wR,Therefore:CR,Theta:AR,theta:SR,thetasym:ER,thetav:TR,thickapprox:DR,thicksim:IR,ThickSpace:zR,ThinSpace:RR,thinsp:NR,thkap:MR,thksim:PR,THORN:VR,thorn:UR,tilde:BR,Tilde:OR,TildeEqual:jR,TildeFullEqual:GR,TildeTilde:HR,timesbar:ZR,timesb:FR,times:$R,timesd:JR,tint:YR,toea:WR,topbot:QR,topcir:KR,top:XR,Topf:eN,topf:rN,topfork:tN,tosa:nN,tprime:sN,trade:oN,TRADE:aN,triangle:iN,triangledown:lN,triangleleft:cN,trianglelefteq:pN,triangleq:uN,triangleright:dN,trianglerighteq:hN,tridot:mN,trie:gN,triminus:fN,TripleDot:bN,triplus:_N,trisb:kN,tritime:yN,trpezium:xN,Tscr:vN,tscr:qN,TScy:LN,tscy:wN,TSHcy:CN,tshcy:AN,Tstrok:SN,tstrok:EN,twixt:TN,twoheadleftarrow:DN,twoheadrightarrow:IN,Uacute:zN,uacute:RN,uarr:NN,Uarr:MN,uArr:PN,Uarrocir:VN,Ubrcy:UN,ubrcy:BN,Ubreve:ON,ubreve:jN,Ucirc:GN,ucirc:HN,Ucy:ZN,ucy:FN,udarr:$N,Udblac:JN,udblac:YN,udhar:WN,ufisht:QN,Ufr:KN,ufr:XN,Ugrave:eM,ugrave:rM,uHar:tM,uharl:nM,uharr:sM,uhblk:oM,ulcorn:aM,ulcorner:iM,ulcrop:lM,ultri:cM,Umacr:pM,umacr:uM,uml:dM,UnderBar:hM,UnderBrace:mM,UnderBracket:gM,UnderParenthesis:fM,Union:bM,UnionPlus:_M,Uogon:kM,uogon:yM,Uopf:xM,uopf:vM,UpArrowBar:qM,uparrow:LM,UpArrow:wM,Uparrow:CM,UpArrowDownArrow:AM,updownarrow:SM,UpDownArrow:EM,Updownarrow:TM,UpEquilibrium:DM,upharpoonleft:IM,upharpoonright:zM,uplus:RM,UpperLeftArrow:NM,UpperRightArrow:MM,upsi:PM,Upsi:VM,upsih:UM,Upsilon:BM,upsilon:OM,UpTeeArrow:jM,UpTee:GM,upuparrows:HM,urcorn:ZM,urcorner:FM,urcrop:$M,Uring:JM,uring:YM,urtri:WM,Uscr:QM,uscr:KM,utdot:XM,Utilde:eP,utilde:rP,utri:tP,utrif:nP,uuarr:sP,Uuml:oP,uuml:aP,uwangle:iP,vangrt:lP,varepsilon:cP,varkappa:pP,varnothing:uP,varphi:dP,varpi:hP,varpropto:mP,varr:gP,vArr:fP,varrho:bP,varsigma:_P,varsubsetneq:kP,varsubsetneqq:yP,varsupsetneq:xP,varsupsetneqq:vP,vartheta:qP,vartriangleleft:LP,vartriangleright:wP,vBar:CP,Vbar:AP,vBarv:SP,Vcy:EP,vcy:TP,vdash:DP,vDash:IP,Vdash:zP,VDash:RP,Vdashl:NP,veebar:MP,vee:PP,Vee:VP,veeeq:UP,vellip:BP,verbar:OP,Verbar:jP,vert:GP,Vert:HP,VerticalBar:ZP,VerticalLine:FP,VerticalSeparator:$P,VerticalTilde:JP,VeryThinSpace:YP,Vfr:WP,vfr:QP,vltri:KP,vnsub:XP,vnsup:eV,Vopf:rV,vopf:tV,vprop:nV,vrtri:sV,Vscr:oV,vscr:aV,vsubnE:iV,vsubne:lV,vsupnE:cV,vsupne:pV,Vvdash:uV,vzigzag:dV,Wcirc:hV,wcirc:mV,wedbar:gV,wedge:fV,Wedge:bV,wedgeq:_V,weierp:kV,Wfr:yV,wfr:xV,Wopf:vV,wopf:qV,wp:LV,wr:wp,wreath:wr,Wscr:wV,wscr:CV,xcap:AV,xcirc:SV,xcup:EV,xdtri:TV,Xfr:DV,xfr:IV,xharr:zV,xhArr:RV,Xi:NV,xi:Xi,xlarr:xi,xlArr:MV,xmap:PV,xnis:VV,xodot:UV,Xopf:BV,xopf:OV,xoplus:jV,xotime:GV,xrarr:HV,xrArr:ZV,Xscr:FV,xscr:$V,xsqcup:JV,xuplus:YV,xutri:WV,xvee:QV,xwedge:KV,Yacute:XV,yacute:eU,YAcy:rU,yacy:tU,Ycirc:nU,ycirc:sU,Ycy:oU,ycy:aU,yen:iU,Yfr:lU,yfr:cU,YIcy:pU,yicy:uU,Yopf:dU,yopf:hU,Yscr:mU,yscr:gU,YUcy:fU,yucy:bU,yuml:_U,Yuml:kU,Zacute:yU,zacute:xU,Zcaron:vU,zcaron:qU,Zcy:LU,zcy:wU,Zdot:CU,zdot:AU,zeetrf:SU,ZeroWidthSpace:EU,Zeta:TU,zeta:DU,zfr:IU,Zfr:zU,ZHcy:RU,zhcy:NU,zigrarr:MU,zopf:PU,Zopf:VU,Zscr:UU,zscr:BU,zwj:OU,zwnj:jU,default:{Aacute:"\xC1",aacute:Se,Abreve:Ee,abreve:Te,ac:De,acd:Ie,acE:ze,Acirc:Ne,acirc:Me,acute:Pe,Acy:Ve,acy:Ue,AElig:Be,aelig:Oe,af:je,Afr:Ge,afr:He,Agrave:Ze,agrave:Fe,alefsym:$e,aleph:Je,Alpha:Ye,alpha:We,Amacr:Qe,amacr:Ke,amalg:Xe,amp:er,AMP:rr,andand:tr,And:nr,and:sr,andd:ar,andslope:ir,andv:lr,ang:cr,ange:ur,angle:dr,angmsdaa:hr,angmsdab:mr,angmsdac:gr,angmsdad:fr,angmsdae:br,angmsdaf:_r,angmsdag:kr,angmsdah:yr,angmsd:xr,angrt:vr,angrtvb:qr,angrtvbd:Lr,angsph:Cr,angst:Ar,angzarr:Sr,Aogon:Er,aogon:Tr,Aopf:Dr,aopf:Ir,apacir:zr,ap:Rr,apE:Nr,ape:Mr,apid:Vr,apos:Ur,ApplyFunction:Br,approx:jr,approxeq:Gr,Aring:Hr,aring:Zr,Ascr:Fr,ascr:$r,Assign:Jr,ast:Yr,asymp:Wr,asympeq:Qr,Atilde:Kr,atilde:Xr,Auml:et,auml:rt,awconint:tt,awint:nt,backcong:st,backepsilon:ot,backprime:at,backsim:ct,backsimeq:pt,Backslash:ut,Barv:dt,barvee:ht,barwed:mt,Barwed:ft,barwedge:bt,bbrk:_t,bbrktbrk:kt,bcong:yt,Bcy:xt,bcy:vt,bdquo:qt,becaus:wt,because:Ct,Because:At,bemptyv:St,bepsi:Et,bernou:Tt,Bernoullis:Dt,Beta:It,beta:zt,beth:Rt,between:Nt,Bfr:Mt,bfr:Pt,bigcap:Vt,bigcirc:Ut,bigcup:Bt,bigodot:Ot,bigoplus:jt,bigotimes:Ht,bigsqcup:Zt,bigstar:Ft,bigtriangledown:$t,bigtriangleup:Jt,biguplus:Yt,bigvee:Wt,bigwedge:Qt,bkarow:Kt,blacklozenge:Xt,blacksquare:en,blacktriangle:rn,blacktriangledown:tn,blacktriangleleft:nn,blacktriangleright:sn,blank:on,blk12:an,blk14:ln,blk34:cn,block:pn,bne:un,bnequiv:dn,bNot:hn,bnot:mn,Bopf:gn,bopf:fn,bot:bn,bottom:_n,bowtie:kn,boxbox:yn,boxdl:xn,boxdL:vn,boxDl:qn,boxDL:Ln,boxdr:wn,boxdR:Cn,boxDr:An,boxDR:Sn,boxh:En,boxH:Tn,boxhd:Dn,boxHd:In,boxhD:zn,boxHD:Rn,boxhu:Nn,boxHu:Mn,boxhU:Pn,boxHU:Vn,boxminus:Un,boxplus:Bn,boxtimes:On,boxul:jn,boxuL:Gn,boxUl:Hn,boxUL:Zn,boxur:Fn,boxuR:$n,boxUr:Jn,boxUR:Yn,boxv:Wn,boxV:Qn,boxvh:Kn,boxvH:Xn,boxVh:es,boxVH:rs,boxvl:ts,boxvL:ns,boxVl:ss,boxVL:os,boxvr:as,boxvR:is,boxVr:ls,boxVR:cs,bprime:ps,breve:us,Breve:ds,brvbar:hs,bscr:ms,Bscr:gs,bsemi:fs,bsim:bs,bsime:_s,bsolb:ks,bsol:ys,bsolhsub:xs,bull:vs,bullet:qs,bump:Ls,bumpE:ws,bumpe:Cs,Bumpeq:As,bumpeq:Ss,Cacute:Es,cacute:Ts,capand:Ds,capbrcup:Is,capcap:zs,cap:Rs,Cap:Ns,capcup:Ms,capdot:Ps,CapitalDifferentialD:Vs,caps:Us,caret:Bs,caron:Os,Cayleys:js,ccaps:Gs,Ccaron:Hs,ccaron:Zs,Ccedil:Fs,ccedil:$s,Ccirc:Js,ccirc:Ys,Cconint:Ws,ccups:Qs,ccupssm:Ks,Cdot:Xs,cdot:eo,cedil:ro,Cedilla:to,cemptyv:no,cent:so,centerdot:oo,CenterDot:ao,cfr:io,Cfr:lo,CHcy:co,chcy:po,check:uo,checkmark:ho,Chi:mo,chi:go,circ:fo,circeq:bo,circlearrowleft:_o,circlearrowright:ko,circledast:yo,circledcirc:xo,circleddash:vo,CircleDot:qo,circledR:Lo,circledS:wo,CircleMinus:Co,CirclePlus:Ao,CircleTimes:So,cir:Eo,cirE:To,cire:Do,cirfnint:Io,cirmid:zo,cirscir:Ro,ClockwiseContourIntegral:No,CloseCurlyDoubleQuote:Mo,CloseCurlyQuote:Po,clubs:Vo,clubsuit:Uo,colon:Bo,Colon:Oo,Colone:jo,colone:Go,coloneq:Ho,comma:Zo,commat:Fo,comp:$o,compfn:Jo,complement:Yo,complexes:Wo,cong:Qo,congdot:Ko,Congruent:Xo,conint:ea,Conint:ra,ContourIntegral:ta,copf:na,Copf:sa,coprod:oa,Coproduct:aa,copy:ia,COPY:la,copysr:ca,CounterClockwiseContourIntegral:pa,crarr:ua,cross:da,Cross:ha,Cscr:ma,cscr:ga,csub:fa,csube:ba,csup:_a,csupe:ka,ctdot:ya,cudarrl:xa,cudarrr:va,cuepr:qa,cuesc:La,cularr:wa,cularrp:Ca,cupbrcap:Aa,cupcap:Sa,CupCap:Ea,cup:Ta,Cup:Da,cupcup:Ia,cupdot:za,cupor:Ra,cups:Na,curarr:Ma,curarrm:Pa,curlyeqprec:Va,curlyeqsucc:Ua,curlyvee:Ba,curlywedge:Oa,curren:ja,curvearrowleft:Ga,curvearrowright:Ha,cuvee:Za,cuwed:Fa,cwconint:$a,cwint:Ja,cylcty:Ya,dagger:Wa,Dagger:Qa,daleth:Ka,darr:Xa,Darr:ei,dArr:ri,dash:ti,Dashv:si,dashv:oi,dbkarow:ai,dblac:li,Dcaron:ci,dcaron:ui,Dcy:di,dcy:hi,ddagger:mi,ddarr:gi,DD:fi,dd:bi,DDotrahd:_i,ddotseq:ki,deg:yi,Del:vi,Delta:qi,delta:Li,demptyv:wi,dfisht:Ci,Dfr:Ai,dfr:Si,dHar:Ei,dharl:Ti,dharr:Di,DiacriticalAcute:Ii,DiacriticalDot:zi,DiacriticalDoubleAcute:Ri,DiacriticalGrave:Ni,DiacriticalTilde:Mi,diam:Vi,diamond:Ui,Diamond:Bi,diamondsuit:Oi,diams:ji,die:Gi,DifferentialD:Hi,digamma:Zi,disin:Fi,div:$i,divide:Ji,divideontimes:Yi,divonx:Wi,DJcy:Qi,djcy:Ki,dlcorn:rl,dlcrop:tl,dollar:nl,Dopf:sl,dopf:ol,Dot:al,dot:il,DotDot:cl,doteq:pl,doteqdot:ul,DotEqual:dl,dotminus:hl,dotplus:ml,dotsquare:fl,doublebarwedge:bl,DoubleContourIntegral:_l,DoubleDot:kl,DoubleDownArrow:yl,DoubleLeftArrow:xl,DoubleLeftRightArrow:vl,DoubleLeftTee:ql,DoubleLongLeftArrow:wl,DoubleLongLeftRightArrow:Cl,DoubleLongRightArrow:Al,DoubleRightArrow:Sl,DoubleRightTee:El,DoubleUpArrow:Tl,DoubleUpDownArrow:Dl,DoubleVerticalBar:Il,DownArrowBar:zl,downarrow:Rl,DownArrow:Nl,Downarrow:Ml,DownArrowUpArrow:Pl,DownBreve:Vl,downdownarrows:Ul,downharpoonleft:Bl,downharpoonright:Ol,DownLeftRightVector:jl,DownLeftTeeVector:Gl,DownLeftVectorBar:Hl,DownLeftVector:Zl,DownRightTeeVector:Fl,DownRightVectorBar:$l,DownRightVector:Jl,DownTeeArrow:Yl,DownTee:Wl,drbkarow:Ql,drcorn:Kl,drcrop:Xl,Dscr:ec,dscr:rc,DScy:tc,dscy:nc,dsol:oc,Dstrok:ac,dstrok:lc,dtdot:cc,dtri:pc,dtrif:uc,duarr:dc,duhar:hc,dwangle:mc,DZcy:gc,dzcy:fc,dzigrarr:bc,Eacute:_c,eacute:kc,easter:yc,Ecaron:xc,ecaron:vc,Ecirc:qc,ecirc:Lc,ecir:wc,ecolon:Cc,Ecy:Ac,ecy:Ec,eDDot:Tc,Edot:Dc,edot:Ic,eDot:zc,ee:Rc,efDot:ee,Efr:Nc,efr:Mc,eg:Pc,Egrave:Vc,egrave:Uc,egs:Bc,egsdot:Oc,el:jc,Element:el,elinters:Gc,ell:Hc,els:Zc,elsdot:Fc,Emacr:$c,emacr:Jc,empty:Yc,emptyset:Wc,EmptySmallSquare:Qc,emptyv:Kc,EmptyVerySmallSquare:Xc,emsp13:ep,emsp14:rp,emsp:tp,ENG:np,eng:sp,ensp:op,Eogon:ap,eogon:ip,Eopf:lp,eopf:cp,epar:pp,eparsl:up,eplus:dp,epsi:hp,Epsilon:gp,epsilon:fp,epsiv:bp,eqcirc:_p,eqcolon:kp,eqsim:yp,eqslantgtr:xp,eqslantless:vp,Equal:qp,equals:Lp,EqualTilde:Cp,equest:Ap,Equilibrium:Sp,equiv:Ep,equivDD:Tp,eqvparsl:Dp,erarr:Ip,erDot:zp,escr:Rp,Escr:Np,esdot:Mp,Esim:Pp,esim:Vp,Eta:Up,eta:Bp,ETH:Op,eth:jp,Euml:Gp,euml:Hp,euro:Zp,excl:Fp,exist:$p,Exists:Jp,expectation:Yp,exponentiale:Wp,ExponentialE:Qp,fallingdotseq:Kp,Fcy:Xp,fcy:eu,female:ru,ffilig:tu,fflig:su,ffllig:ou,Ffr:au,ffr:iu,filig:lu,FilledSmallSquare:cu,FilledVerySmallSquare:pu,fjlig:uu,flat:du,fllig:hu,fltns:gu,fnof:fu,Fopf:bu,fopf:_u,forall:ku,ForAll:yu,fork:xu,forkv:vu,Fouriertrf:qu,fpartint:Lu,frac12:wu,frac13:Cu,frac14:Au,frac15:Su,frac16:Eu,frac18:Tu,frac23:Du,frac25:Iu,frac34:zu,frac35:Ru,frac38:Pu,frac45:Vu,frac56:Uu,frac58:Bu,frac78:Ou,frasl:ju,frown:Gu,fscr:Hu,Fscr:Zu,gacute:Fu,Gamma:$u,gamma:Ju,Gammad:Yu,gammad:Wu,gap:Qu,Gbreve:Ku,gbreve:Xu,Gcedil:ed,Gcirc:rd,gcirc:td,Gcy:nd,gcy:sd,Gdot:od,gdot:ad,ge:id,gE:ge,gEl:ld,gel:cd,geq:pd,geqq:ud,geqslant:dd,gescc:hd,ges:md,gesdot:gd,gesdoto:fd,gesdotol:bd,gesl:_d,gesles:kd,Gfr:yd,gfr:xd,gg:vd,Gg:qd,ggg:Ld,gimel:wd,GJcy:Cd,gjcy:Ad,gla:Sd,gl:Ed,glE:gl,glj:Td,gnap:Dd,gnapprox:Id,gne:zd,gnE:Rd,gneq:Nd,gneqq:Md,gnsim:Pd,Gopf:Vd,gopf:Ud,grave:Bd,GreaterEqual:Od,GreaterEqualLess:jd,GreaterFullEqual:Gd,GreaterGreater:Hd,GreaterLess:Zd,GreaterSlantEqual:Fd,GreaterTilde:$d,Gscr:Jd,gscr:Yd,gsim:Wd,gsime:Qd,gsiml:Kd,gtcc:Xd,gtcir:eh,gt:rh,GT:gt,Gt:th,gtdot:Gt,gtlPar:nh,gtquest:sh,gtrapprox:oh,gtrarr:ah,gtrdot:ih,gtreqless:lh,gtreqqless:ch,gtrless:ph,gtrsim:uh,gvertneqq:dh,gvnE:hh,Hacek:mh,hairsp:gh,half:fh,hamilt:bh,HARDcy:_h,hardcy:kh,harrcir:yh,harr:xh,hArr:vh,harrw:qh,Hat:Lh,hbar:wh,Hcirc:Ch,hcirc:Ah,hearts:Sh,heartsuit:Eh,hellip:Th,hercon:Dh,hfr:Ih,Hfr:zh,HilbertSpace:Rh,hksearow:Nh,hkswarow:Mh,hoarr:Ph,homtht:Vh,hookleftarrow:Uh,hookrightarrow:Bh,hopf:Oh,Hopf:jh,horbar:Gh,HorizontalLine:Hh,hscr:Zh,Hscr:Fh,hslash:$h,Hstrok:Jh,hstrok:Yh,HumpDownHump:Wh,HumpEqual:Qh,hybull:Kh,hyphen:Xh,Iacute:em,iacute:rm,ic:tm,Icirc:ic,icirc:nm,Icy:sm,icy:om,Idot:am,IEcy:im,iecy:lm,iexcl:cm,iff:um,ifr:dm,Ifr:hm,Igrave:mm,igrave:gm,ii:fm,iiiint:ii,iiint:bm,iinfin:_m,iiota:km,IJlig:ym,ijlig:xm,Imacr:vm,imacr:qm,image:Lm,ImaginaryI:wm,imagline:Cm,imagpart:Am,imath:Sm,Im:Em,imof:Tm,imped:Dm,Implies:Im,incare:zm,in:"\u2208",infin:Rm,infintie:Nm,inodot:Mm,intcal:Pm,int:Vm,Int:Um,integers:Bm,Integral:Om,intercal:jm,Intersection:Gm,intlarhk:Hm,intprod:Zm,InvisibleComma:Fm,InvisibleTimes:$m,IOcy:Jm,iocy:Ym,Iogon:Wm,iogon:Qm,Iopf:Km,iopf:Xm,Iota:eg,iota:rg,iprod:tg,iquest:ng,iscr:sg,Iscr:og,isin:ag,isindot:ig,isinE:cg,isins:pg,isinsv:ug,isinv:dg,it:hg,Itilde:it,itilde:mg,Iukcy:gg,iukcy:fg,Iuml:bg,iuml:_g,Jcirc:kg,jcirc:yg,Jcy:xg,jcy:vg,Jfr:qg,jfr:Lg,jmath:wg,Jopf:Cg,jopf:Ag,Jscr:Sg,jscr:Eg,Jsercy:Tg,jsercy:Dg,Jukcy:Ig,jukcy:zg,Kappa:Rg,kappa:Ng,kappav:Mg,Kcedil:Pg,kcedil:Vg,Kcy:Ug,kcy:Bg,Kfr:Og,kfr:jg,kgreen:Gg,KHcy:Hg,khcy:Zg,KJcy:Fg,kjcy:$g,Kopf:Jg,kopf:Yg,Kscr:Wg,kscr:Qg,lAarr:Kg,Lacute:Xg,lacute:ef,laemptyv:rf,lagran:tf,Lambda:nf,lambda:sf,lang:of,Lang:af,langd:lf,langle:cf,lap:pf,Laplacetrf:uf,laquo:df,larrb:hf,larrbfs:mf,larr:gf,Larr:ff,lArr:bf,larrfs:_f,larrhk:kf,larrlp:yf,larrpl:xf,larrsim:vf,larrtl:qf,latail:Lf,lAtail:wf,lat:Cf,late:Af,lates:Sf,lbarr:Ef,lBarr:Tf,lbbrk:Df,lbrace:If,lbrack:zf,lbrke:Rf,lbrksld:Nf,lbrkslu:Mf,Lcaron:Pf,lcaron:Vf,Lcedil:Uf,lcedil:Bf,lceil:Of,lcub:jf,Lcy:Gf,lcy:Hf,ldca:Zf,ldquo:Ff,ldquor:$f,ldrdhar:Jf,ldrushar:Yf,ldsh:Wf,le:Qf,lE:le,LeftAngleBracket:Kf,LeftArrowBar:Xf,leftarrow:eb,LeftArrow:rb,Leftarrow:tb,LeftArrowRightArrow:nb,leftarrowtail:sb,LeftCeiling:ob,LeftDoubleBracket:ab,LeftDownTeeVector:ib,LeftDownVectorBar:lb,LeftDownVector:cb,LeftFloor:pb,leftharpoondown:ub,leftharpoonup:db,leftleftarrows:hb,leftrightarrow:mb,LeftRightArrow:gb,Leftrightarrow:fb,leftrightarrows:bb,leftrightharpoons:_b,leftrightsquigarrow:kb,LeftRightVector:yb,LeftTeeArrow:xb,LeftTee:vb,LeftTeeVector:qb,leftthreetimes:Lb,LeftTriangleBar:wb,LeftTriangle:Cb,LeftTriangleEqual:Ab,LeftUpDownVector:Sb,LeftUpTeeVector:Eb,LeftUpVectorBar:Tb,LeftUpVector:Db,LeftVectorBar:Ib,LeftVector:zb,lEg:Rb,leg:Nb,leq:Mb,leqq:Pb,leqslant:Vb,lescc:Ub,les:Bb,lesdot:Ob,lesdoto:jb,lesdotor:Gb,lesg:Hb,lesges:Zb,lessapprox:Fb,lessdot:$b,lesseqgtr:Jb,lesseqqgtr:Yb,LessEqualGreater:Wb,LessFullEqual:Qb,LessGreater:Kb,lessgtr:Xb,LessLess:e_,lesssim:r_,LessSlantEqual:t_,LessTilde:n_,lfisht:s_,lfloor:o_,Lfr:a_,lfr:i_,lg:l_,lgE:lg,lHar:c_,lhard:p_,lharu:u_,lharul:d_,lhblk:h_,LJcy:m_,ljcy:g_,llarr:f_,ll:b_,Ll:ll,llcorner:Ll,Lleftarrow:__,llhard:k_,lltri:y_,Lmidot:x_,lmidot:v_,lmoustache:q_,lmoust:L_,lnap:w_,lnapprox:C_,lne:A_,lnE:S_,lneq:E_,lneqq:T_,lnsim:D_,loang:I_,loarr:z_,lobrk:R_,longleftarrow:N_,LongLeftArrow:M_,Longleftarrow:P_,longleftrightarrow:V_,LongLeftRightArrow:U_,Longleftrightarrow:B_,longmapsto:O_,longrightarrow:j_,LongRightArrow:G_,Longrightarrow:H_,looparrowleft:Z_,looparrowright:F_,lopar:$_,Lopf:J_,lopf:Y_,loplus:W_,lotimes:Q_,lowast:K_,lowbar:X_,LowerLeftArrow:ek,LowerRightArrow:rk,loz:tk,lozenge:nk,lozf:sk,lpar:ok,lparlt:ak,lrarr:ik,lrcorner:lk,lrhar:ck,lrhard:pk,lrm:uk,lrtri:dk,lsaquo:hk,lscr:mk,Lscr:gk,lsh:fk,Lsh:bk,lsim:_k,lsime:kk,lsimg:yk,lsqb:xk,lsquo:vk,lsquor:qk,Lstrok:Lk,lstrok:wk,ltcc:Ck,ltcir:Ak,lt:Sk,LT:lt,Lt:Ek,ltdot:Lt,lthree:Tk,ltimes:Dk,ltlarr:Ik,ltquest:zk,ltri:Rk,ltrie:Nk,ltrif:Mk,ltrPar:Pk,lurdshar:Vk,luruhar:Uk,lvertneqq:Bk,lvnE:Ok,macr:jk,male:Gk,malt:Hk,maltese:Zk,Map:"\u2905",map:Fk,mapsto:$k,mapstodown:Jk,mapstoleft:Yk,mapstoup:Wk,marker:Qk,mcomma:Kk,Mcy:Xk,mcy:ey,mdash:ry,mDDot:ty,measuredangle:ny,MediumSpace:sy,Mellintrf:oy,Mfr:ay,mfr:iy,mho:ly,micro:cy,midast:py,midcir:uy,mid:dy,middot:hy,minusb:my,minus:gy,minusd:fy,minusdu:by,MinusPlus:_y,mlcp:ky,mldr:yy,mnplus:xy,models:vy,Mopf:qy,mopf:Ly,mp:wy,mscr:mp,Mscr:Cy,mstpos:Ay,Mu:Sy,mu:Mu,multimap:mu,mumap:Ey,nabla:Ty,Nacute:Dy,nacute:Iy,nang:zy,nap:Ry,napE:Ny,napid:My,napos:Py,napprox:Vy,natural:Uy,naturals:By,natur:Oy,nbsp:jy,nbump:Gy,nbumpe:Hy,ncap:Zy,Ncaron:Fy,ncaron:$y,Ncedil:Jy,ncedil:Yy,ncong:Wy,ncongdot:Qy,ncup:Ky,Ncy:Xy,ncy:ex,ndash:tx,nearhk:nx,nearr:sx,neArr:ox,nearrow:ax,ne:ix,nedot:ne,NegativeMediumSpace:lx,NegativeThickSpace:cx,NegativeThinSpace:px,NegativeVeryThinSpace:ux,nequiv:dx,nesear:hx,nesim:mx,NestedGreaterGreater:gx,NestedLessLess:fx,NewLine:bx,nexist:_x,nexists:kx,Nfr:yx,nfr:xx,ngE:vx,nge:qx,ngeq:Lx,ngeqq:wx,ngeqslant:Cx,nges:Ax,nGg:Sx,ngsim:Ex,nGt:Tx,ngt:Dx,ngtr:Ix,nGtv:zx,nharr:Rx,nhArr:Nx,nhpar:Mx,ni:Px,nis:ni,nisd:Vx,niv:Ux,NJcy:Bx,njcy:Ox,nlarr:jx,nlArr:Gx,nldr:Hx,nlE:Zx,nle:Fx,nleftarrow:$x,nLeftarrow:Jx,nleftrightarrow:Yx,nLeftrightarrow:Wx,nleq:Qx,nleqq:Kx,nleqslant:Xx,nles:ev,nless:rv,nLl:tv,nlsim:nv,nLt:sv,nlt:ov,nltri:av,nltrie:iv,nLtv:lv,nmid:cv,NoBreak:pv,NonBreakingSpace:uv,nopf:dv,Nopf:hv,Not:mv,not:gv,NotCongruent:fv,NotCupCap:bv,NotDoubleVerticalBar:_v,NotElement:kv,NotEqual:yv,NotEqualTilde:xv,NotExists:vv,NotGreater:qv,NotGreaterEqual:Lv,NotGreaterFullEqual:wv,NotGreaterGreater:Cv,NotGreaterLess:Av,NotGreaterSlantEqual:Sv,NotGreaterTilde:Ev,NotHumpDownHump:Tv,NotHumpEqual:Dv,notin:Iv,notindot:zv,notinE:Rv,notinva:Nv,notinvb:Mv,notinvc:Pv,NotLeftTriangleBar:Vv,NotLeftTriangle:Uv,NotLeftTriangleEqual:Bv,NotLess:Ov,NotLessEqual:jv,NotLessGreater:Gv,NotLessLess:Hv,NotLessSlantEqual:Zv,NotLessTilde:Fv,NotNestedGreaterGreater:$v,NotNestedLessLess:Jv,notni:Yv,notniva:Wv,notnivb:Qv,notnivc:Kv,NotPrecedes:Xv,NotPrecedesEqual:eq,NotPrecedesSlantEqual:rq,NotReverseElement:tq,NotRightTriangleBar:nq,NotRightTriangle:sq,NotRightTriangleEqual:oq,NotSquareSubset:aq,NotSquareSubsetEqual:iq,NotSquareSuperset:lq,NotSquareSupersetEqual:cq,NotSubset:pq,NotSubsetEqual:uq,NotSucceeds:dq,NotSucceedsEqual:hq,NotSucceedsSlantEqual:mq,NotSucceedsTilde:gq,NotSuperset:fq,NotSupersetEqual:bq,NotTilde:_q,NotTildeEqual:kq,NotTildeFullEqual:yq,NotTildeTilde:xq,NotVerticalBar:vq,nparallel:qq,npar:Lq,nparsl:wq,npart:Cq,npolint:Aq,npr:Sq,nprcue:Eq,nprec:Tq,npreceq:Dq,npre:Iq,nrarrc:zq,nrarr:Rq,nrArr:Nq,nrarrw:Mq,nrightarrow:Pq,nRightarrow:Vq,nrtri:Uq,nrtrie:Bq,nsc:Oq,nsccue:jq,nsce:Gq,Nscr:Hq,nscr:Zq,nshortmid:Fq,nshortparallel:$q,nsim:Jq,nsime:Yq,nsimeq:Wq,nsmid:Qq,nspar:Kq,nsqsube:Xq,nsqsupe:eL,nsub:rL,nsubE:tL,nsube:nL,nsubset:sL,nsubseteq:oL,nsubseteqq:aL,nsucc:iL,nsucceq:lL,nsup:cL,nsupE:pL,nsupe:uL,nsupset:dL,nsupseteq:hL,nsupseteqq:mL,ntgl:gL,Ntilde:fL,ntilde:bL,ntlg:_L,ntriangleleft:kL,ntrianglelefteq:yL,ntriangleright:xL,ntrianglerighteq:vL,Nu:qL,nu:Nu,num:nu,numero:LL,numsp:wL,nvap:CL,nvdash:AL,nvDash:SL,nVdash:EL,nVDash:TL,nvge:DL,nvgt:IL,nvHarr:zL,nvinfin:RL,nvlArr:NL,nvle:ML,nvlt:PL,nvltrie:VL,nvrArr:UL,nvrtrie:BL,nvsim:OL,nwarhk:jL,nwarr:GL,nwArr:HL,nwarrow:ZL,nwnear:FL,Oacute:$L,oacute:JL,oast:YL,Ocirc:WL,ocirc:QL,ocir:KL,Ocy:XL,ocy:ew,odash:rw,Odblac:tw,odblac:nw,odiv:sw,odot:ow,odsold:aw,OElig:iw,oelig:lw,ofcir:cw,Ofr:pw,ofr:uw,ogon:dw,Ograve:hw,ograve:mw,ogt:gw,ohbar:fw,ohm:bw,oint:_w,olarr:kw,olcir:yw,olcross:xw,oline:vw,olt:qw,Omacr:Lw,omacr:ww,Omega:Cw,omega:Aw,Omicron:Sw,omicron:Ew,omid:Tw,ominus:Dw,Oopf:Iw,oopf:zw,opar:Rw,OpenCurlyDoubleQuote:Nw,OpenCurlyQuote:Mw,operp:Pw,oplus:Vw,orarr:Uw,Or:Bw,or:Or,ord:or,order:Ow,orderof:jw,ordf:Gw,ordm:Hw,origof:Zw,oror:Fw,orslope:$w,orv:Jw,oS:Yw,Oscr:Ww,oscr:Qw,Oslash:Kw,oslash:Xw,osol:eC,Otilde:rC,otilde:tC,otimesas:nC,Otimes:sC,otimes:oC,Ouml:aC,ouml:iC,ovbar:lC,OverBar:cC,OverBrace:pC,OverBracket:uC,OverParenthesis:dC,para:hC,parallel:mC,par:gC,parsim:fC,parsl:bC,part:_C,PartialD:kC,Pcy:yC,pcy:xC,percnt:vC,period:qC,permil:LC,perp:wC,pertenk:CC,Pfr:AC,pfr:SC,Phi:EC,phi:TC,phiv:DC,phmmat:IC,phone:zC,Pi:RC,pi:Pi,pitchfork:pi,piv:NC,planck:MC,planckh:PC,plankv:VC,plusacir:UC,plusb:BC,pluscir:OC,plus:jC,plusdo:GC,plusdu:HC,pluse:ZC,PlusMinus:FC,plusmn:$C,plussim:JC,plustwo:YC,pm:WC,Poincareplane:pm,pointint:QC,popf:KC,Popf:XC,pound:eA,prap:rA,Pr:tA,pr:Pr,prcue:pr,precapprox:nA,prec:sA,preccurlyeq:oA,Precedes:aA,PrecedesEqual:iA,PrecedesSlantEqual:lA,PrecedesTilde:cA,preceq:pA,precnapprox:uA,precneqq:dA,precnsim:hA,pre:mA,prE:gA,precsim:fA,prime:bA,Prime:_A,primes:kA,prnap:yA,prnE:xA,prnsim:vA,prod:qA,Product:LA,profalar:wA,profline:CA,profsurf:AA,prop:SA,Proportional:EA,Proportion:TA,propto:DA,prsim:IA,prurel:zA,Pscr:RA,pscr:NA,Psi:MA,psi:PA,puncsp:VA,Qfr:UA,qfr:BA,qint:OA,qopf:jA,Qopf:GA,qprime:HA,Qscr:ZA,qscr:FA,quaternions:$A,quatint:JA,quest:YA,questeq:WA,quot:QA,QUOT:KA,rAarr:XA,race:eS,Racute:rS,racute:tS,radic:nS,raemptyv:sS,rang:oS,Rang:aS,rangd:iS,range:lS,rangle:cS,raquo:pS,rarrap:uS,rarrb:dS,rarrbfs:hS,rarrc:mS,rarr:gS,Rarr:fS,rArr:bS,rarrfs:_S,rarrhk:kS,rarrlp:yS,rarrpl:xS,rarrsim:vS,Rarrtl:qS,rarrtl:LS,rarrw:wS,ratail:CS,rAtail:AS,ratio:SS,rationals:ES,rbarr:TS,rBarr:DS,RBarr:IS,rbbrk:zS,rbrace:RS,rbrack:NS,rbrke:MS,rbrksld:PS,rbrkslu:VS,Rcaron:US,rcaron:BS,Rcedil:OS,rcedil:jS,rceil:GS,rcub:HS,Rcy:ZS,rcy:FS,rdca:$S,rdldhar:JS,rdquo:YS,rdquor:WS,rdsh:QS,real:KS,realine:XS,realpart:eE,reals:rE,Re:tE,rect:Re,reg:nE,REG:sE,ReverseElement:oE,ReverseEquilibrium:aE,ReverseUpEquilibrium:iE,rfisht:lE,rfloor:cE,rfr:pE,Rfr:uE,rHar:dE,rhard:hE,rharu:mE,rharul:gE,Rho:fE,rho:bE,rhov:_E,RightAngleBracket:kE,RightArrowBar:yE,rightarrow:xE,RightArrow:vE,Rightarrow:qE,RightArrowLeftArrow:LE,rightarrowtail:wE,RightCeiling:CE,RightDoubleBracket:AE,RightDownTeeVector:SE,RightDownVectorBar:EE,RightDownVector:TE,RightFloor:DE,rightharpoondown:IE,rightharpoonup:zE,rightleftarrows:RE,rightleftharpoons:NE,rightrightarrows:ME,rightsquigarrow:PE,RightTeeArrow:VE,RightTee:UE,RightTeeVector:BE,rightthreetimes:OE,RightTriangleBar:jE,RightTriangle:GE,RightTriangleEqual:HE,RightUpDownVector:ZE,RightUpTeeVector:FE,RightUpVectorBar:$E,RightUpVector:JE,RightVectorBar:YE,RightVector:WE,ring:QE,risingdotseq:KE,rlarr:XE,rlhar:eT,rlm:rT,rmoustache:tT,rmoust:nT,rnmid:sT,roang:oT,roarr:aT,robrk:iT,ropar:lT,ropf:cT,Ropf:pT,roplus:uT,rotimes:dT,RoundImplies:hT,rpar:mT,rpargt:gT,rppolint:fT,rrarr:bT,Rrightarrow:_T,rsaquo:kT,rscr:yT,Rscr:xT,rsh:vT,Rsh:qT,rsqb:LT,rsquo:wT,rsquor:CT,rthree:AT,rtimes:ST,rtri:ET,rtrie:TT,rtrif:DT,rtriltri:IT,RuleDelayed:zT,ruluhar:RT,rx:NT,Sacute:rx,sacute:MT,sbquo:PT,scap:VT,Scaron:UT,scaron:BT,Sc:OT,sc:Sc,sccue:sc,sce:jT,scE:GT,Scedil:HT,scedil:ZT,Scirc:FT,scirc:$T,scnap:JT,scnE:YT,scnsim:WT,scpolint:QT,scsim:KT,Scy:XT,scy:eD,sdotb:rD,sdot:tD,sdote:nD,searhk:sD,searr:oD,seArr:aD,searrow:iD,sect:lD,semi:cD,seswar:pD,setminus:uD,setmn:dD,sext:hD,Sfr:mD,sfr:gD,sfrown:fD,sharp:bD,SHCHcy:_D,shchcy:kD,SHcy:yD,shcy:xD,ShortDownArrow:vD,ShortLeftArrow:qD,shortmid:LD,shortparallel:wD,ShortRightArrow:CD,ShortUpArrow:AD,shy:SD,Sigma:ED,sigma:TD,sigmaf:DD,sigmav:ID,sim:zD,simdot:RD,sime:ND,simeq:MD,simg:PD,simgE:VD,siml:UD,simlE:BD,simne:OD,simplus:jD,simrarr:GD,slarr:HD,SmallCircle:ZD,smallsetminus:FD,smashp:$D,smeparsl:JD,smid:YD,smile:WD,smt:QD,smte:KD,smtes:XD,SOFTcy:eI,softcy:rI,solbar:tI,solb:nI,sol:sI,Sopf:oI,sopf:aI,spades:iI,spadesuit:lI,spar:cI,sqcap:pI,sqcaps:uI,sqcup:dI,sqcups:hI,Sqrt:mI,sqsub:gI,sqsube:fI,sqsubset:bI,sqsubseteq:_I,sqsup:kI,sqsupe:yI,sqsupset:xI,sqsupseteq:vI,square:qI,Square:LI,SquareIntersection:wI,SquareSubset:CI,SquareSubsetEqual:AI,SquareSuperset:SI,SquareSupersetEqual:EI,SquareUnion:TI,squarf:DI,squ:II,squf:zI,srarr:RI,Sscr:NI,sscr:MI,ssetmn:PI,ssmile:VI,sstarf:UI,Star:BI,star:OI,starf:jI,straightepsilon:GI,straightphi:HI,strns:ZI,sub:FI,Sub:$I,subdot:JI,subE:YI,sube:WI,subedot:QI,submult:KI,subnE:XI,subne:ez,subplus:rz,subrarr:tz,subset:nz,Subset:sz,subseteq:oz,subseteqq:az,SubsetEqual:iz,subsetneq:lz,subsetneqq:cz,subsim:pz,subsub:uz,subsup:dz,succapprox:hz,succ:mz,succcurlyeq:gz,Succeeds:fz,SucceedsEqual:bz,SucceedsSlantEqual:_z,SucceedsTilde:kz,succeq:yz,succnapprox:xz,succneqq:vz,succnsim:qz,succsim:Lz,SuchThat:wz,sum:Cz,Sum:Az,sung:Sz,sup1:Ez,sup2:Tz,sup3:Dz,sup:Iz,Sup:zz,supdot:Rz,supdsub:Nz,supE:Mz,supe:Pz,supedot:Vz,Superset:Uz,SupersetEqual:Bz,suphsol:Oz,suphsub:jz,suplarr:Gz,supmult:Hz,supnE:Zz,supne:Fz,supplus:$z,supset:Jz,Supset:Yz,supseteq:Wz,supseteqq:Qz,supsetneq:Kz,supsetneqq:Xz,supsim:eR,supsub:rR,supsup:tR,swarhk:nR,swarr:sR,swArr:oR,swarrow:aR,swnwar:iR,szlig:lR,Tab:cR,target:pR,Tau:uR,tau:dR,tbrk:hR,Tcaron:mR,tcaron:gR,Tcedil:fR,tcedil:bR,Tcy:_R,tcy:kR,tdot:yR,telrec:xR,Tfr:vR,tfr:qR,there4:LR,therefore:wR,Therefore:CR,Theta:AR,theta:SR,thetasym:ER,thetav:TR,thickapprox:DR,thicksim:IR,ThickSpace:zR,ThinSpace:RR,thinsp:NR,thkap:MR,thksim:PR,THORN:VR,thorn:UR,tilde:BR,Tilde:OR,TildeEqual:jR,TildeFullEqual:GR,TildeTilde:HR,timesbar:ZR,timesb:FR,times:$R,timesd:JR,tint:YR,toea:WR,topbot:QR,topcir:KR,top:XR,Topf:eN,topf:rN,topfork:tN,tosa:nN,tprime:sN,trade:oN,TRADE:aN,triangle:iN,triangledown:lN,triangleleft:cN,trianglelefteq:pN,triangleq:uN,triangleright:dN,trianglerighteq:hN,tridot:mN,trie:gN,triminus:fN,TripleDot:bN,triplus:_N,trisb:kN,tritime:yN,trpezium:xN,Tscr:vN,tscr:qN,TScy:LN,tscy:wN,TSHcy:CN,tshcy:AN,Tstrok:SN,tstrok:EN,twixt:TN,twoheadleftarrow:DN,twoheadrightarrow:IN,Uacute:zN,uacute:RN,uarr:NN,Uarr:MN,uArr:PN,Uarrocir:VN,Ubrcy:UN,ubrcy:BN,Ubreve:ON,ubreve:jN,Ucirc:GN,ucirc:HN,Ucy:ZN,ucy:FN,udarr:$N,Udblac:JN,udblac:YN,udhar:WN,ufisht:QN,Ufr:KN,ufr:XN,Ugrave:eM,ugrave:rM,uHar:tM,uharl:nM,uharr:sM,uhblk:oM,ulcorn:aM,ulcorner:iM,ulcrop:lM,ultri:cM,Umacr:pM,umacr:uM,uml:dM,UnderBar:hM,UnderBrace:mM,UnderBracket:gM,UnderParenthesis:fM,Union:bM,UnionPlus:_M,Uogon:kM,uogon:yM,Uopf:xM,uopf:vM,UpArrowBar:qM,uparrow:LM,UpArrow:wM,Uparrow:CM,UpArrowDownArrow:AM,updownarrow:SM,UpDownArrow:EM,Updownarrow:TM,UpEquilibrium:DM,upharpoonleft:IM,upharpoonright:zM,uplus:RM,UpperLeftArrow:NM,UpperRightArrow:MM,upsi:PM,Upsi:VM,upsih:UM,Upsilon:BM,upsilon:OM,UpTeeArrow:jM,UpTee:GM,upuparrows:HM,urcorn:ZM,urcorner:FM,urcrop:$M,Uring:JM,uring:YM,urtri:WM,Uscr:QM,uscr:KM,utdot:XM,Utilde:eP,utilde:rP,utri:tP,utrif:nP,uuarr:sP,Uuml:oP,uuml:aP,uwangle:iP,vangrt:lP,varepsilon:cP,varkappa:pP,varnothing:uP,varphi:dP,varpi:hP,varpropto:mP,varr:gP,vArr:fP,varrho:bP,varsigma:_P,varsubsetneq:kP,varsubsetneqq:yP,varsupsetneq:xP,varsupsetneqq:vP,vartheta:qP,vartriangleleft:LP,vartriangleright:wP,vBar:CP,Vbar:AP,vBarv:SP,Vcy:EP,vcy:TP,vdash:DP,vDash:IP,Vdash:zP,VDash:RP,Vdashl:NP,veebar:MP,vee:PP,Vee:VP,veeeq:UP,vellip:BP,verbar:OP,Verbar:jP,vert:GP,Vert:HP,VerticalBar:ZP,VerticalLine:FP,VerticalSeparator:$P,VerticalTilde:JP,VeryThinSpace:YP,Vfr:WP,vfr:QP,vltri:KP,vnsub:XP,vnsup:eV,Vopf:rV,vopf:tV,vprop:nV,vrtri:sV,Vscr:oV,vscr:aV,vsubnE:iV,vsubne:lV,vsupnE:cV,vsupne:pV,Vvdash:uV,vzigzag:dV,Wcirc:hV,wcirc:mV,wedbar:gV,wedge:fV,Wedge:bV,wedgeq:_V,weierp:kV,Wfr:yV,wfr:xV,Wopf:vV,wopf:qV,wp:LV,wr:wp,wreath:wr,Wscr:wV,wscr:CV,xcap:AV,xcirc:SV,xcup:EV,xdtri:TV,Xfr:DV,xfr:IV,xharr:zV,xhArr:RV,Xi:NV,xi:Xi,xlarr:xi,xlArr:MV,xmap:PV,xnis:VV,xodot:UV,Xopf:BV,xopf:OV,xoplus:jV,xotime:GV,xrarr:HV,xrArr:ZV,Xscr:FV,xscr:$V,xsqcup:JV,xuplus:YV,xutri:WV,xvee:QV,xwedge:KV,Yacute:XV,yacute:eU,YAcy:rU,yacy:tU,Ycirc:nU,ycirc:sU,Ycy:oU,ycy:aU,yen:iU,Yfr:lU,yfr:cU,YIcy:pU,yicy:uU,Yopf:dU,yopf:hU,Yscr:mU,yscr:gU,YUcy:fU,yucy:bU,yuml:_U,Yuml:kU,Zacute:yU,zacute:xU,Zcaron:vU,zcaron:qU,Zcy:LU,zcy:wU,Zdot:CU,zdot:AU,zeetrf:SU,ZeroWidthSpace:EU,Zeta:TU,zeta:DU,zfr:IU,Zfr:zU,ZHcy:RU,zhcy:NU,zigrarr:MU,zopf:PU,Zopf:VU,Zscr:UU,zscr:BU,zwj:OU,zwnj:jU}}),HU=function(e){return e&&e["default"]||e}(GU),ZU=HU,FU=/[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/,$U={};o.defaultChars=";/?:@&=+$,-_.!~*'()#",o.componentChars="-_.!~*'()";var JU={};/* eslint-disable no-bitwise */l.defaultChars=";/?:@&=+$,#",l.componentChars="";var YU=/^([a-z0-9.+-]+:)/i,WU=/:[0-9]*$/,// Special case for a simple path URL
QU=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,// RFC 2396: characters not allowed for various reasons.
KU=["{","}","|","\\","^","`"].concat(["<",">","\"","`"," ","\r","\n","\t"]),// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
XU=["'"].concat(KU),// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
eB=["%","/","?",";","#"].concat(XU),rB=["/","?","#"],tB=/^[+a-z0-9A-Z_-]{0,63}$/,nB=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,// protocols that can allow "unsafe" and "unwise" chars.
/* eslint-disable no-script-url */ // protocols that never have a hostname.
sB={javascript:!0,"javascript:":!0},// protocols that always contain a // bit.
oB={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0};c.prototype.parse=function(e,r){var t=e,n,s,o,a,c;// trim before proceeding.
// This is to support parse stuff like "  http://foo.com  \n"
if(t=t.trim(),!r&&1===e.split("#").length){// Try fast path regexp
var p=QU.exec(t);if(p)return this.pathname=p[1],p[2]&&(this.search=p[2]),this}var u=YU.exec(t);if(u&&(u=u[0],o=u.toLowerCase(),this.protocol=u,t=t.substr(u.length)),(r||u||t.match(/^\/\/[^@\/]+@[^@\/]+/))&&(c="//"===t.substr(0,2),c&&!(u&&sB[u])&&(t=t.substr(2),this.slashes=!0)),!sB[u]&&(c||u&&!oB[u])){// there's a hostname.
// the first instance of /, ?, ;, or # ends the host.
//
// If there is an @ in the hostname, then non-host chars *are* allowed
// to the left of the last @ sign, unless some host-ending character
// comes *before* the @-sign.
// URLs are obnoxious.
//
// ex:
// http://a@b@c/ => user:a@b host:c
// http://a@b?@c => user:a host:c path:/?@c
// v0.12 TODO(isaacs): This is not quite how Chrome does things.
// Review our test case against browsers more comprehensively.
// find the first instance of any hostEndingChars
var d=-1;for(n=0;n<rB.length;n++)a=t.indexOf(rB[n]),-1!==a&&(-1===d||a<d)&&(d=a);// at this point, either we have an explicit point where the
// auth portion cannot go past, or the last @ char is the decider.
var h,m;for(m=-1===d?t.lastIndexOf("@"):t.lastIndexOf("@",d),-1!==m&&(h=t.slice(0,m),t=t.slice(m+1),this.auth=h),d=-1,n=0;n<eB.length;n++)a=t.indexOf(eB[n]),-1!==a&&(-1===d||a<d)&&(d=a);// if we still have not hit it, then the entire thing is a host.
-1===d&&(d=t.length),":"===t[d-1]&&d--;var g=t.slice(0,d);t=t.slice(d),this.parseHost(g),this.hostname=this.hostname||"";// if hostname begins with [ and ends with ]
// assume that it's an IPv6 address.
var f="["===this.hostname[0]&&"]"===this.hostname[this.hostname.length-1];// validate a little.
if(!f){var b=this.hostname.split(/\./);for(n=0,s=b.length;n<s;n++){var _=b[n];if(_&&!_.match(tB)){for(var y="",x=0,v=_.length;x<v;x++)y+=127<_.charCodeAt(x)?// we replace non-ASCII char with a temporary placeholder
// we need this to make sure size of hostname is not
// broken by replacing non-ASCII by nothing
"x":_[x];// we test again with ASCII char only
if(!y.match(tB)){var k=b.slice(0,n),q=b.slice(n+1),L=_.match(nB);L&&(k.push(L[1]),q.unshift(L[2])),q.length&&(t=q.join(".")+t),this.hostname=k.join(".");break}}}}this.hostname.length>255&&(this.hostname=""),f&&(this.hostname=this.hostname.substr(1,this.hostname.length-2))}// chop off from the tail first.
var w=t.indexOf("#");-1!==w&&(this.hash=t.substr(w),t=t.slice(0,w));var C=t.indexOf("?");return-1!==C&&(this.search=t.substr(C),t=t.slice(0,C)),t&&(this.pathname=t),oB[o]&&this.hostname&&!this.pathname&&(this.pathname=""),this},c.prototype.parseHost=function(e){var r=WU.exec(e);r&&(r=r[0],":"!==r&&(this.port=r.substr(1)),e=e.substr(0,e.length-r.length)),e&&(this.hostname=e)};var aB={encode:o,decode:l,format:function(e){var r="";return r+=e.protocol||"",r+=e.slashes?"//":"",r+=e.auth?e.auth+"@":"",r+=e.hostname&&-1!==e.hostname.indexOf(":")?"["+e.hostname+"]":e.hostname||"",r+=e.port?":"+e.port:"",r+=e.pathname||"",r+=e.search||"",r+=e.hash||"",r},parse:/* eslint-enable no-script-url */function(e,r){if(e&&e instanceof c)return e;var t=new c;return t.parse(e,r),t}},iB=/[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,lB=/[\0-\x1F\x7F-\x9F]/,cB=/[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/,pB=/[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/,uB={Any:iB,Cc:lB,Cf:cB,P:FU,Z:pB},dB=function(e,r){return r={exports:{}},e(r,r.exports),r.exports}(function(e,r){function t(e){return Object.prototype.toString.call(e)}function n(e,r){return l.call(e,r)}// Merge objects
//
////////////////////////////////////////////////////////////////////////////////
function s(e){/*eslint no-bitwise:0*/ // broken sequence
return!(55296<=e&&57343>=e)&&!(64976<=e&&65007>=e)&&65535!=(65535&e)&&65534!=(65535&e)&&!(0<=e&&8>=e)&&11!==e&&!(14<=e&&31>=e)&&!(127<=e&&159>=e)&&!(1114111<e);// never used
// control codes
// out of range
}function o(e){/*eslint no-bitwise:0*/if(65535<e){e-=65536;var r=55296+(e>>10),t=56320+(1023&e);return Ae(r,t)}return Ae(e)}function a(e,r){var t=0;return n(ZU,r)?ZU[r]:35===r.charCodeAt(0)/* # */&&d.test(r)&&(t="x"===r[1].toLowerCase()?parseInt(r.slice(2),16):parseInt(r.slice(1),10),s(t))?o(t):e}/*function replaceEntities(str) {
	    if (str.indexOf('&') < 0) { return str; }
	  
	    return str.replace(ENTITY_RE, replaceEntityPattern);
	  }*/function i(e){return g[e]}var l=Object.prototype.hasOwnProperty,c=/\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g,p=/&([a-z#][a-z0-9]{1,31});/gi,u=new RegExp(c.source+"|"+p.source,"gi"),d=/^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i,h=/[&<>"]/,m=/[&<>"]/g,g={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"},f=/[.?*+^$[\]\\(){}|-]/g;r.lib={},r.lib.mdurl=aB,r.lib.ucmicro=uB,r.assign=function(e/*from1, from2, from3, ...*/){var r=Array.prototype.slice.call(arguments,1);return r.forEach(function(r){if(r){if("object"!=typeof r)throw new TypeError(r+"must be object");Object.keys(r).forEach(function(t){e[t]=r[t]})}}),e}// Remove element from array and put another array at those position.
// Useful for some operations with tokens
,r.isString=function(e){return"[object String]"===t(e)},r.has=n,r.unescapeMd=function(e){return 0>e.indexOf("\\")?e:e.replace(c,"$1")},r.unescapeAll=function(e){return 0>e.indexOf("\\")&&0>e.indexOf("&")?e:e.replace(u,function(e,r,t){return r?r:a(e,t)})}////////////////////////////////////////////////////////////////////////////////
,r.isValidEntityCode=s,r.fromCodePoint=o,r.escapeHtml=function(e){return h.test(e)?e.replace(m,i):e}////////////////////////////////////////////////////////////////////////////////
,r.arrayReplaceAt=function(e,r,t){return[].concat(e.slice(0,r),t,e.slice(r+1))},r.isSpace=////////////////////////////////////////////////////////////////////////////////
function(e){return 9===e||32===e}// Zs (unicode class) || [\t\f\v\r\n]
,r.isWhiteSpace=function(e){return!!(8192<=e&&8202>=e)||9===e||10===e||11===e||12===e||13===e||32===e||160===e||5760===e||8239===e||8287===e||12288===e}////////////////////////////////////////////////////////////////////////////////
/*eslint-disable max-len*/ // Currently without astral characters support.
,r.isMdAsciiPunct=// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function(e){return 33/* ! */===e||34/* " */===e||35/* # */===e||36/* $ */===e||37/* % */===e||38/* & */===e||39/* ' */===e||40/* ( */===e||41/* ) */===e||42/* * */===e||43/* + */===e||44/* , */===e||45/* - */===e||46/* . */===e||47/* / */===e||58/* : */===e||59/* ; */===e||60/* < */===e||61/* = */===e||62/* > */===e||63/* ? */===e||64/* @ */===e||91/* [ */===e||92/* \ */===e||93/* ] */===e||94/* ^ */===e||95/* _ */===e||96/* ` */===e||123/* { */===e||124/* | */===e||125/* } */===e||126/* ~ */===e}// Hepler to unify [reference labels].
//
,r.isPunctChar=function(e){return FU.test(e)},r.escapeRE=function(e){return e.replace(f,"\\$&")},r.normalizeReference=function(e){// .toLowerCase().toUpperCase() should get rid of all differences
// between letter variants.
//
// Simple .toLowerCase() doesn't normalize 125 code points correctly,
// and .toUpperCase doesn't normalize 6 of them (list of exceptions:
// İ, ϴ, ẞ, Ω, K, Å - those are already uppercased, but have differently
// uppercased versions).
//
// Here's an example showing how it happens. Lets take greek letter omega:
// uppercase U+0398 (Θ), U+03f4 (ϴ) and lowercase U+03b8 (θ), U+03d1 (ϑ)
//
// Unicode entries:
// 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;
// 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398
// 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398
// 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;
//
// Case-insensitive comparison should treat all of them as equivalent.
//
// But .toLowerCase() doesn't change ϑ (it's already lowercase),
// and .toUpperCase() doesn't change ϴ (already uppercase).
//
// Applying first lower then upper case normalizes any character:
// '\u0398\u03f4\u03b8\u03d1'.toLowerCase().toUpperCase() === '\u0398\u0398\u0398\u0398'
//
// Note: this is equivalent to unicode case folding; unicode normalization
// is a different step that is not required here.
//
// Final result should be uppercased, because it's later stored in an object
// (this avoid a conflict with Object.prototype members,
// most notably, `__proto__`)
//
return e=e.trim().replace(/\s+/g," "),"\u1E7E"==="\u1E9E".toLowerCase()&&(e=e.replace(/ẞ/g,"\xDF")),e.toLowerCase().toUpperCase()}////////////////////////////////////////////////////////////////////////////////
// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
}),hB=dB.lib,mB=dB.assign,gB=dB.isString,fB=dB.has,bB=dB.unescapeMd,_B=dB.unescapeAll,kB=dB.isValidEntityCode,yB=dB.fromCodePoint,xB=dB.escapeHtml,vB=dB.arrayReplaceAt,qB=dB.isSpace,LB=dB.isWhiteSpace,wB=dB.isMdAsciiPunct,CB=dB.isPunctChar,AB=dB.escapeRE,SB=dB.normalizeReference,EB=dB.unescapeAll,TB=dB.unescapeAll,DB={parseLinkLabel:function(e,r,t){var n=-1,s=e.posMax,o=e.pos,a,i,l,c;for(e.pos=r+1,a=1;e.pos<s;){if(l=e.src.charCodeAt(e.pos),93===l&&(a--,0===a)/* ] */){i=!0;break}if(c=e.pos,e.md.inline.skipToken(e),91===l/* [ */)if(c===e.pos-1)a++;else if(t)return e.pos=o,-1}return i&&(n=e.pos),e.pos=o,n},parseLinkDestination:function(e,r,t){var n=r,s={ok:!1,pos:0,lines:0,str:""},o,a;if(60===e.charCodeAt(r)/* < */){for(r++;r<t;){if(o=e.charCodeAt(r),10===o/* \n */)return s;if(62===o/* > */)return s.pos=r+1,s.str=EB(e.slice(n+1,r)),s.ok=!0,s;if(92===o/* \ */&&r+1<t){r+=2;continue}r++}// no closing '>'
return s}// this should be ... } else { ... branch
for(a=0;r<t&&(o=e.charCodeAt(r),32!==o)&&!(32>o||127===o);){if(92===o/* \ */&&r+1<t){r+=2;continue}if(40===o/* ( */&&a++,41===o/* ) */){if(0===a)break;a--}r++}return n===r?s:0===a?(s.str=EB(e.slice(n,r)),s.lines=0,s.pos=r,s.ok=!0,s):s},parseLinkTitle:function(e,r,t){var n=0,s=r,o={ok:!1,pos:0,lines:0,str:""},a,i;if(r>=t)return o;if(i=e.charCodeAt(r),34!==i/* " */&&39!==i/* ' */&&40!==i/* ( */)return o;for(r++,40===i&&(i=41);r<t;){if(a=e.charCodeAt(r),a===i)return o.pos=r+1,o.lines=n,o.str=TB(e.slice(s+1,r)),o.ok=!0,o;10===a?n++:92===a/* \ */&&r+1<t&&(r++,10===e.charCodeAt(r)&&n++),r++}return o}},IB=dB.assign,zB=dB.unescapeAll,RB=dB.escapeHtml,NB={};NB.code_inline=function(e,r,t,n,s){var o=e[r];return"<code"+s.renderAttrs(o)+">"+RB(e[r].content)+"</code>"},NB.code_block=function(e,r,t,n,s){var o=e[r];return"<pre"+s.renderAttrs(o)+"><code>"+RB(e[r].content)+"</code></pre>\n"},NB.fence=function(e,r,t,n,s){var o=e[r],a=o.info?zB(o.info).trim():"",l="",c,p,u,d;return a&&(l=a.split(/\s+/g)[0]),c=t.highlight?t.highlight(o.content,l)||RB(o.content):RB(o.content),0===c.indexOf("<pre")?c+"\n":a?(p=o.attrIndex("class"),u=o.attrs?o.attrs.slice():[],0>p?u.push(["class",t.langPrefix+l]):u[p][1]+=" "+t.langPrefix+l,d={attrs:u},"<pre><code"+s.renderAttrs(d)+">"+c+"</code></pre>\n"):"<pre><code"+s.renderAttrs(o)+">"+c+"</code></pre>\n";// If language exists, inject class gently, without modifying original token.
// May be, one day we will add .clone() for token and simplify this part, but
// now we prefer to keep things local.
},NB.image=function(e,r,t,n,s){var o=e[r];// "alt" attr MUST be set, even if empty. Because it's mandatory and
// should be placed on proper position for tests.
//
// Replace content with actual value
return o.attrs[o.attrIndex("alt")][1]=s.renderInlineAsText(o.children,t,n),s.renderToken(e,r,t)},NB.hardbreak=function(e,r,t/*, env */){return t.xhtmlOut?"<br />\n":"<br>\n"},NB.softbreak=function(e,r,t/*, env */){return t.breaks?t.xhtmlOut?"<br />\n":"<br>\n":"\n"},NB.text=function(e,r/*, options, env */){return RB(e[r].content)},NB.html_block=function(e,r/*, options, env */){return e[r].content},NB.html_inline=function(e,r/*, options, env */){return e[r].content},p.prototype.renderAttrs=function(e){var r,t,n;if(!e.attrs)return"";for(n="",r=0,t=e.attrs.length;r<t;r++)n+=" "+RB(e.attrs[r][0])+"=\""+RB(e.attrs[r][1])+"\"";return n},p.prototype.renderToken=function(e,r,t){var n="",s=!1,o=e[r],a;// Tight list paragraphs
return o.hidden?"":(o.block&&-1!==o.nesting&&r&&e[r-1].hidden&&(n+="\n"),n+=(-1===o.nesting?"</":"<")+o.tag,n+=this.renderAttrs(o),0===o.nesting&&t.xhtmlOut&&(n+=" /"),o.block&&(s=!0,1===o.nesting&&r+1<e.length&&(a=e[r+1],"inline"===a.type||a.hidden?s=!1:-1===a.nesting&&a.tag===o.tag&&(s=!1))),n+=s?">\n":">",n);// Insert a newline between hidden paragraph and subsequent opening
// block-level tag.
//
// For example, here we should insert a newline before blockquote:
//  - a
//    >
//
},p.prototype.renderInline=function(e,r,t){for(var n="",s=this.rules,o=0,a=e.length,l;o<a;o++)l=e[o].type,n+="undefined"==typeof s[l]?this.renderToken(e,o,r):s[l](e,o,r,t,this);return n},p.prototype.renderInlineAsText=function(e,r,t){for(var n="",s=0,o=e.length;s<o;s++)"text"===e[s].type?n+=e[s].content:"image"===e[s].type&&(n+=this.renderInlineAsText(e[s].children,r,t));return n},p.prototype.render=function(e,r,t){var n="",s=this.rules,o,a,l;for(o=0,a=e.length;o<a;o++)l=e[o].type,n+="inline"===l?this.renderInline(e[o].children,r,t):"undefined"==typeof s[l]?this.renderToken(e,o,r,t):s[e[o].type](e,o,r,t,this);return n};var MB=p;u.prototype.__find__=function(e){for(var r=0;r<this.__rules__.length;r++)if(this.__rules__[r].name===e)return r;return-1},u.prototype.__compile__=function(){var e=this,r=[""];e.__rules__.forEach(function(e){e.enabled&&e.alt.forEach(function(e){0>r.indexOf(e)&&r.push(e)})}),e.__cache__={},r.forEach(function(r){e.__cache__[r]=[],e.__rules__.forEach(function(t){!t.enabled||r&&0>t.alt.indexOf(r)||e.__cache__[r].push(t.fn)})})},u.prototype.at=function(e,r,t){var n=this.__find__(e);if(-1===n)throw new Error("Parser rule not found: "+e);this.__rules__[n].fn=r,this.__rules__[n].alt=(t||{}).alt||[],this.__cache__=null},u.prototype.before=function(e,r,t,n){var s=this.__find__(e);if(-1===s)throw new Error("Parser rule not found: "+e);this.__rules__.splice(s,0,{name:r,enabled:!0,fn:t,alt:(n||{}).alt||[]}),this.__cache__=null},u.prototype.after=function(e,r,t,n){var s=this.__find__(e);if(-1===s)throw new Error("Parser rule not found: "+e);this.__rules__.splice(s+1,0,{name:r,enabled:!0,fn:t,alt:(n||{}).alt||[]}),this.__cache__=null},u.prototype.push=function(e,r,t){this.__rules__.push({name:e,enabled:!0,fn:r,alt:(t||{}).alt||[]}),this.__cache__=null},u.prototype.enable=function(e,r){Array.isArray(e)||(e=[e]);var t=[];// Search by name and enable
return e.forEach(function(e){var n=this.__find__(e);if(0>n){if(r)return;throw new Error("Rules manager: invalid rule name "+e)}this.__rules__[n].enabled=!0,t.push(e)},this),this.__cache__=null,t},u.prototype.enableOnly=function(e,r){Array.isArray(e)||(e=[e]),this.__rules__.forEach(function(e){e.enabled=!1}),this.enable(e,r)},u.prototype.disable=function(e,r){Array.isArray(e)||(e=[e]);var t=[];// Search by name and disable
return e.forEach(function(e){var n=this.__find__(e);if(0>n){if(r)return;throw new Error("Rules manager: invalid rule name "+e)}this.__rules__[n].enabled=!1,t.push(e)},this),this.__cache__=null,t},u.prototype.getRules=function(e){// Chain can be empty, if rules disabled. But we still have to return Array.
return null===this.__cache__&&this.__compile__(),this.__cache__[e]||[]};var PB=u,VB=/\r\n?|\n/g,UB=/\0/g,BB=function(e){var r=e.tokens,t,n,s;// Parse inlines
for(n=0,s=r.length;n<s;n++)t=r[n],"inline"===t.type&&e.md.inline.parse(t.content,e.md,e.env,t.children)},OB=dB.arrayReplaceAt,jB=function(e){var r=e.tokens,t,n,s,o,a,c,p,u,m,g,f,b,_,k,y,x,v;if(e.md.options.linkify)for(n=0,s=r.length;n<s;n++)if("inline"===r[n].type&&e.md.linkify.pretest(r[n].content))// We scan from the end, to keep position when new tags added.
// Use reversed logic in links start/end match
for(o=r[n].children,_=0,t=o.length-1;0<=t;t--){// Skip content of markdown links
if(c=o[t],"link_close"===c.type){for(t--;o[t].level!==c.level&&"link_open"!==o[t].type;)t--;continue}// Skip content of html tag links
if(("html_inline"===c.type&&(d(c.content)&&0<_&&_--,h(c.content)&&_++),!(0<_))&&"text"===c.type&&e.md.linkify.test(c.content)){for(m=c.content,v=e.md.linkify.match(m),p=[],b=c.level,f=0,u=0;u<v.length;u++)(k=v[u].url,y=e.md.normalizeLink(k),!!e.md.validateLink(y))&&(x=v[u].text,x=v[u].schema?"mailto:"!==v[u].schema||/^mailto:/i.test(x)?e.md.normalizeLinkText(x):e.md.normalizeLinkText("mailto:"+x).replace(/^mailto:/,""):e.md.normalizeLinkText("http://"+x).replace(/^http:\/\//,""),g=v[u].index,g>f&&(a=new e.Token("text","",0),a.content=m.slice(f,g),a.level=b,p.push(a)),a=new e.Token("link_open","a",1),a.attrs=[["href",y]],a.level=b++,a.markup="linkify",a.info="auto",p.push(a),a=new e.Token("text","",0),a.content=x,a.level=b,p.push(a),a=new e.Token("link_close","a",-1),a.level=--b,a.markup="linkify",a.info="auto",p.push(a),f=v[u].lastIndex);f<m.length&&(a=new e.Token("text","",0),a.content=m.slice(f),a.level=b,p.push(a)),r[n].children=o=OB(o,t,p)}}},GB=/\+-|\.\.|\?\?\?\?|!!!!|,,|--/,HB=/\((c|tm|r|p)\)/i,ZB=/\((c|tm|r|p)\)/ig,FB={c:"\xA9",r:"\xAE",p:"\xA7",tm:"\u2122"},$B=dB.isWhiteSpace,JB=dB.isPunctChar,YB=dB.isMdAsciiPunct,WB=/['"]/,QB=/['"]/g;// Normalize input string
k.prototype.attrIndex=function(e){var r,t,n;if(!this.attrs)return-1;for(r=this.attrs,t=0,n=r.length;t<n;t++)if(r[t][0]===e)return t;return-1},k.prototype.attrPush=function(e){this.attrs?this.attrs.push(e):this.attrs=[e]},k.prototype.attrSet=function(e,r){var t=this.attrIndex(e),n=[e,r];0>t?this.attrPush(n):this.attrs[t]=n},k.prototype.attrGet=function(e){var r=this.attrIndex(e),t=null;return 0<=r&&(t=this.attrs[r][1]),t},k.prototype.attrJoin=function(e,r){var t=this.attrIndex(e);0>t?this.attrPush([e,r]):this.attrs[t][1]=this.attrs[t][1]+" "+r};var KB=k;y.prototype.Token=KB;var XB=[["normalize",function(e){var r;// Normalize newlines
r=e.src.replace(VB,"\n"),r=r.replace(UB,"\uFFFD"),e.src=r}],["block",function(e){var r;e.inlineMode?(r=new e.Token("inline","",0),r.content=e.src,r.map=[0,1],r.children=[],e.tokens.push(r)):e.md.block.parse(e.src,e.md,e.env,e.tokens)}],["inline",BB],["linkify",jB],["replacements",function(e){var r;if(e.md.options.typographer)for(r=e.tokens.length-1;0<=r;r--)"inline"===e.tokens[r].type&&(HB.test(e.tokens[r].content)&&g(e.tokens[r].children),GB.test(e.tokens[r].content)&&f(e.tokens[r].children))}],["smartquotes",function(e){/*eslint max-depth:0*/var r;if(e.md.options.typographer)for(r=e.tokens.length-1;0<=r;r--)"inline"===e.tokens[r].type&&WB.test(e.tokens[r].content)&&_(e.tokens[r].children,e)}]];x.prototype.process=function(e){var r,t,n;for(n=this.ruler.getRules(""),r=0,t=n.length;r<t;r++)n[r](e)},x.prototype.State=y;var eO=x,rO=dB.isSpace,tO=function(e,r,n,s){var o,a,l,c,p,u,d,h,m,g,f,b;// should have at least two lines
if(r+2>n)return!1;if(p=r+1,e.sCount[p]<e.blkIndent)return!1;// if it's indented more than 3 spaces, it should be a code block
if(4<=e.sCount[p]-e.blkIndent)return!1;// first character of the second line should be '|', '-', ':',
// and no other characters are allowed but spaces;
// basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp
if(l=e.bMarks[p]+e.tShift[p],l>=e.eMarks[p])return!1;if(o=e.src.charCodeAt(l++),124!==o/* | */&&45!==o/* - */&&58!==o/* : */)return!1;for(;l<e.eMarks[p];){if(o=e.src.charCodeAt(l),124!==o/* | */&&45!==o/* - */&&58!==o/* : */&&!rO(o))return!1;l++}for(a=v(e,r+1),u=a.split("|"),m=[],c=0;c<u.length;c++){if(g=u[c].trim(),!g)// allow empty columns before and after table, but not in between columns;
// e.g. allow ` |---| `, disallow ` ---||--- `
if(0===c||c===u.length-1)continue;else return!1;if(!/^:?-+:?$/.test(g))return!1;58===g.charCodeAt(g.length-1)/* : */?m.push(58===g.charCodeAt(0)/* : */?"center":"right"):58===g.charCodeAt(0)/* : */?m.push("left"):m.push("")}if(a=v(e,r).trim(),-1===a.indexOf("|"))return!1;if(4<=e.sCount[r]-e.blkIndent)return!1;if(u=q(a.replace(/^\||\|$/g,"")),d=u.length,d>m.length)return!1;if(s)return!0;for(h=e.push("table_open","table",1),h.map=f=[r,0],h=e.push("thead_open","thead",1),h.map=[r,r+1],h=e.push("tr_open","tr",1),h.map=[r,r+1],c=0;c<u.length;c++)h=e.push("th_open","th",1),h.map=[r,r+1],m[c]&&(h.attrs=[["style","text-align:"+m[c]]]),h=e.push("inline","",0),h.content=u[c].trim(),h.map=[r,r+1],h.children=[],h=e.push("th_close","th",-1);for(h=e.push("tr_close","tr",-1),h=e.push("thead_close","thead",-1),h=e.push("tbody_open","tbody",1),h.map=b=[r+2,0],p=r+2;p<n&&!(e.sCount[p]<e.blkIndent)&&(a=v(e,p).trim(),-1!==a.indexOf("|"))&&!(4<=e.sCount[p]-e.blkIndent);p++){for(u=q(a.replace(/^\||\|$/g,"")),h=e.push("tr_open","tr",1),c=0;c<d;c++)h=e.push("td_open","td",1),m[c]&&(h.attrs=[["style","text-align:"+m[c]]]),h=e.push("inline","",0),h.content=u[c]?u[c].trim():"",h.children=[],h=e.push("td_close","td",-1);h=e.push("tr_close","tr",-1)}return h=e.push("tbody_close","tbody",-1),h=e.push("table_close","table",-1),f[1]=b[1]=p,e.line=p,!0},nO=dB.isSpace,sO=function(e,r,t,n){var s=e.lineMax,o=e.bMarks[r]+e.tShift[r],a=e.eMarks[r],c,p,u,d,h,m,g,f,b,_,k,y,x,v,q,L,w,C,A,S;// if it's indented more than 3 spaces, it should be a code block
if(4<=e.sCount[r]-e.blkIndent)return!1;// check the block quote marker
if(62!==e.src.charCodeAt(o++)/* > */)return!1;// we know that it's going to be a valid blockquote,
// so no point trying to find the end of it in silent mode
if(n)return!0;// skip spaces after ">" and re-calculate offset
for(d=b=e.sCount[r]+o-(e.bMarks[r]+e.tShift[r]),32===e.src.charCodeAt(o)/* space */?(o++,d++,b++,c=!1,L=!0):9===e.src.charCodeAt(o)/* tab */?(L=!0,3==(e.bsCount[r]+b)%4?(o++,d++,b++,c=!1):c=!0):L=!1,_=[e.bMarks[r]],e.bMarks[r]=o;o<a&&(p=e.src.charCodeAt(o),nO(p));)9===p?b+=4-(b+e.bsCount[r]+(c?1:0))%4:b++,o++;// Search the end of the block
//
// Block ends with either:
//  1. an empty line outside:
//     ```
//     > test
//
//     ```
//  2. an empty line inside:
//     ```
//     >
//     test
//     ```
//  3. another tag:
//     ```
//     > test
//      - - -
//     ```
for(k=[e.bsCount[r]],e.bsCount[r]=e.sCount[r]+1+(L?1:0),m=o>=a,v=[e.sCount[r]],e.sCount[r]=b-d,q=[e.tShift[r]],e.tShift[r]=o-e.bMarks[r],C=e.md.block.ruler.getRules("blockquote"),x=e.parentType,e.parentType="blockquote",S=!1,f=r+1;f<t&&(e.sCount[f]<e.blkIndent&&(S=!0),o=e.bMarks[f]+e.tShift[f],a=e.eMarks[f],!(o>=a));f++){if(62===e.src.charCodeAt(o++)/* > */&&!S){for(d=b=e.sCount[f]+o-(e.bMarks[f]+e.tShift[f]),32===e.src.charCodeAt(o)/* space */?(o++,d++,b++,c=!1,L=!0):9===e.src.charCodeAt(o)/* tab */?(L=!0,3==(e.bsCount[f]+b)%4?(o++,d++,b++,c=!1):c=!0):L=!1,_.push(e.bMarks[f]),e.bMarks[f]=o;o<a&&(p=e.src.charCodeAt(o),nO(p));)9===p?b+=4-(b+e.bsCount[f]+(c?1:0))%4:b++,o++;m=o>=a,k.push(e.bsCount[f]),e.bsCount[f]=e.sCount[f]+1+(L?1:0),v.push(e.sCount[f]),e.sCount[f]=b-d,q.push(e.tShift[f]),e.tShift[f]=o-e.bMarks[f];continue}// Case 2: line is not inside the blockquote, and the last line was empty.
if(m)break;// Case 3: another tag found.
for(w=!1,u=0,h=C.length;u<h;u++)if(C[u](e,f,t,!0)){w=!0;break}if(w){e.lineMax=f,0!==e.blkIndent&&(_.push(e.bMarks[f]),k.push(e.bsCount[f]),q.push(e.tShift[f]),v.push(e.sCount[f]),e.sCount[f]-=e.blkIndent);break}_.push(e.bMarks[f]),k.push(e.bsCount[f]),q.push(e.tShift[f]),v.push(e.sCount[f]),e.sCount[f]=-1}// Restore original tShift; this might not be necessary since the parser
// has already been here, but just to make sure we can do that.
for(y=e.blkIndent,e.blkIndent=0,A=e.push("blockquote_open","blockquote",1),A.markup=">",A.map=g=[r,0],e.md.block.tokenize(e,r,f),A=e.push("blockquote_close","blockquote",-1),A.markup=">",e.lineMax=s,e.parentType=x,g[1]=e.line,u=0;u<q.length;u++)e.bMarks[u+r]=_[u],e.tShift[u+r]=q[u],e.sCount[u+r]=v[u],e.bsCount[u+r]=k[u];return e.blkIndent=y,!0},oO=dB.isSpace,aO=dB.isSpace,iO=function(e,r,t,n){var s=Math.min,o=!1,a=!0,c,p,u,d,h,m,g,f,b,_,k,y,x,v,q,A,S,E,T,D,I,z,R,N,M,P,V,U;// if it's indented more than 3 spaces, it should be a code block
if(4<=e.sCount[r]-e.blkIndent)return!1;// Special case:
//  - item 1
//   - item 2
//    - item 3
//     - item 4
//      - this one is a paragraph continuation
if(0<=e.listIndent&&4<=e.sCount[r]-e.listIndent&&e.sCount[r]<e.blkIndent)return!1;// limit conditions when list can interrupt
// a paragraph (validation mode only)
// Detect list type and position after marker
if(n&&"paragraph"===e.parentType&&e.tShift[r]>=e.blkIndent&&(o=!0),0<=(R=w(e,r))){// If we're starting a new ordered list right after
// a paragraph, it should start with 1.
if(g=!0,M=e.bMarks[r]+e.tShift[r],x=+e.src.substr(M,R-M-1),o&&1!==x)return!1;}else if(0<=(R=L(e,r)))g=!1;else return!1;// If we're starting a new unordered list right after
// a paragraph, first line should not be empty.
if(o&&e.skipSpaces(R)>=e.eMarks[r])return!1;// We should terminate list on style change. Remember first one to compare.
// For validation mode we can terminate immediately
if(y=e.src.charCodeAt(R-1),n)return!0;// Start list
for(k=e.tokens.length,g?(U=e.push("ordered_list_open","ol",1),1!==x&&(U.attrs=[["start",x]])):U=e.push("bullet_list_open","ul",1),U.map=_=[r,0],U.markup=Ae(y),q=r,N=!1,V=e.md.block.ruler.getRules("list"),E=e.parentType,e.parentType="list";q<t;){for(z=R,v=e.eMarks[q],m=A=e.sCount[q]+R-(e.bMarks[r]+e.tShift[r]);z<v;){if(c=e.src.charCodeAt(z),9===c)A+=4-(A+e.bsCount[q])%4;else if(32===c)A++;else break;z++}if(p=z,h=p>=v?1:A-m,4<h&&(h=1),d=m+h,U=e.push("list_item_open","li",1),U.markup=Ae(y),U.map=f=[r,0],I=e.tight,D=e.tShift[r],T=e.sCount[r],S=e.listIndent,e.listIndent=e.blkIndent,e.blkIndent=d,e.tight=!0,e.tShift[r]=p-e.bMarks[r],e.sCount[r]=A,p>=v&&e.isEmpty(r+1)?e.line=s(e.line+2,t):e.md.block.tokenize(e,r,t,!0),(!e.tight||N)&&(a=!1),N=1<e.line-r&&e.isEmpty(e.line-1),e.blkIndent=e.listIndent,e.listIndent=S,e.tShift[r]=D,e.sCount[r]=T,e.tight=I,U=e.push("list_item_close","li",-1),U.markup=Ae(y),q=r=e.line,f[1]=q,p=e.bMarks[r],q>=t)break;//
// Try to check if list is terminated or continued.
//
if(e.sCount[q]<e.blkIndent)break;// if it's indented more than 3 spaces, it should be a code block
if(4<=e.sCount[r]-e.blkIndent)break;// fail if terminating block found
for(P=!1,u=0,b=V.length;u<b;u++)if(V[u](e,q,t,!0)){P=!0;break}if(P)break;// fail if list has another type
if(g){if(R=w(e,q),0>R)break;}else if(R=L(e,q),0>R)break;if(y!==e.src.charCodeAt(R-1))break}// Finalize list
return U=g?e.push("ordered_list_close","ol",-1):e.push("bullet_list_close","ul",-1),U.markup=Ae(y),_[1]=q,e.line=q,e.parentType=E,a&&C(e,k),!0},lO=dB.normalizeReference,cO=dB.isSpace,pO=function(e,r,t,n){var s=0,o=e.bMarks[r]+e.tShift[r],a=e.eMarks[r],c=r+1,p,u,d,h,m,g,f,b,_,k,y,x,v,q,L,w;// if it's indented more than 3 spaces, it should be a code block
if(4<=e.sCount[r]-e.blkIndent)return!1;if(91!==e.src.charCodeAt(o)/* [ */)return!1;// Simple check to quickly interrupt scan on [link](url) at the start of line.
// Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
for(;++o<a;)if(93===e.src.charCodeAt(o)/* ] */&&92!==e.src.charCodeAt(o-1)/* \ */){if(o+1===a)return!1;if(58!==e.src.charCodeAt(o+1)/* : */)return!1;break}for(h=e.lineMax,L=e.md.block.ruler.getRules("reference"),k=e.parentType,e.parentType="reference";c<h&&!e.isEmpty(c);c++)// this would be a code block normally, but after paragraph
// it's considered a lazy continuation regardless of what's there
if(!(3<e.sCount[c]-e.blkIndent)&&!(0>e.sCount[c]))// quirk for blockquotes, this line should already be checked by that rule
{for(q=!1,g=0,f=L.length;g<f;g++)if(L[g](e,c,h,!0)){q=!0;break}if(q)break}// Some tags can terminate paragraph without empty line.
for(v=e.getLines(r,c,e.blkIndent,!1).trim(),a=v.length,o=1;o<a;o++){if(p=v.charCodeAt(o),91===p/* [ */)return!1;if(93===p/* ] */){_=o;break}else 10===p/* \n */?s++:92===p/* \ */&&(o++,o<a&&10===v.charCodeAt(o)&&s++)}if(0>_||58!==v.charCodeAt(_+1)/* : */)return!1;// [label]:   destination   'title'
//         ^^^ skip optional whitespace here
for(o=_+2;o<a;o++)if(p=v.charCodeAt(o),10===p)s++;else if(cO(p));else break;// [label]:   destination   'title'
//            ^^^^^^^^^^^ parse this
if(y=e.md.helpers.parseLinkDestination(v,o,a),!y.ok)return!1;if(m=e.md.normalizeLink(y.str),!e.md.validateLink(m))return!1;for(o=y.pos,s+=y.lines,u=o,d=s,x=o;o<a;o++)if(p=v.charCodeAt(o),10===p)s++;else if(cO(p));else break;// [label]:   destination   'title'
//                          ^^^^^^^ parse this
// skip trailing spaces until the rest of the line
for(y=e.md.helpers.parseLinkTitle(v,o,a),o<a&&x!==o&&y.ok?(w=y.str,o=y.pos,s+=y.lines):(w="",o=u,s=d);o<a&&(p=v.charCodeAt(o),!!cO(p));)o++;if(o<a&&10!==v.charCodeAt(o)&&w)for(w="",o=u,s=d;o<a&&(p=v.charCodeAt(o),!!cO(p));)o++;return!(o<a&&10!==v.charCodeAt(o))&&(b=lO(v.slice(1,_)),!!b)&&(!!n||("undefined"==typeof e.env.references&&(e.env.references={}),"undefined"==typeof e.env.references[b]&&(e.env.references[b]={title:w,href:m}),e.parentType=k,e.line=r+s+1,!0));// Reference can not terminate anything. This check is for safety only.
/*istanbul ignore if*/},uO=dB.isSpace,dO=function(e,r,t/*, silent*/){var n=r+1,s=e.md.block.ruler.getRules("paragraph"),o,a,c,p,u,d,h,m,g,f;// if it's indented more than 3 spaces, it should be a code block
if(4<=e.sCount[r]-e.blkIndent)return!1;// use paragraph to match terminatorRules
// jump line-by-line until empty one or EOF
for(f=e.parentType,e.parentType="paragraph";n<t&&!e.isEmpty(n);n++)// this would be a code block normally, but after paragraph
// it's considered a lazy continuation regardless of what's there
if(!(3<e.sCount[n]-e.blkIndent)){//
// Check for underline in setext header
//
if(e.sCount[n]>=e.blkIndent&&(d=e.bMarks[n]+e.tShift[n],h=e.eMarks[n],d<h&&(g=e.src.charCodeAt(d),(45===g/* - */||61===g)&&(d=e.skipChars(d,g),d=e.skipSpaces(d),d>=h)/* = */))){m=61===g/* = */?1:2;break}// quirk for blockquotes, this line should already be checked by that rule
if(!(0>e.sCount[n])){for(a=!1,c=0,p=s.length;c<p;c++)if(s[c](e,n,t,!0)){a=!0;break}if(a)break}// Some tags can terminate paragraph without empty line.
}return!!m&&(o=e.getLines(r,n,e.blkIndent,!1).trim(),e.line=n+1,u=e.push("heading_open","h"+(m+""),1),u.markup=Ae(g),u.map=[r,e.line],u=e.push("inline","",0),u.content=o,u.map=[r,e.line-1],u.children=[],u=e.push("heading_close","h"+(m+""),-1),u.markup=Ae(g),e.parentType=f,!0)},hO="<[A-Za-z][A-Za-z0-9\\-]*"+("(?:\\s+"+"[a-zA-Z_:][a-zA-Z0-9:._-]*"+"(?:\\s*=\\s*"+("(?:"+"[^\"'=<>`\\x00-\\x20]+"+"|"+"'[^']*'"+"|"+"\"[^\"]*\""+")")+")?)")+"*\\s*\\/?>",mO="<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>",gO=new RegExp("^(?:"+hO+"|"+mO+"|"+"<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->"+"|"+"<[?].*?[?]>"+"|"+"<![A-Z]+\\s+[^>]*>"+"|"+"<!\\[CDATA\\[[\\s\\S]*?\\]\\]>"+")"),fO=new RegExp("^(?:"+hO+"|"+mO+")"),bO={HTML_TAG_RE:gO,HTML_OPEN_CLOSE_TAG_RE:fO},_O=bO.HTML_OPEN_CLOSE_TAG_RE,kO=[[/^<(script|pre|style)(?=(\s|>|$))/i,/<\/(script|pre|style)>/i,!0],[/^<!--/,/-->/,!0],[/^<\?/,/\?>/,!0],[/^<![A-Z]/,/>/,!0],[/^<!\[CDATA\[/,/\]\]>/,!0],[new RegExp("^</?("+["address","article","aside","base","basefont","blockquote","body","caption","center","col","colgroup","dd","details","dialog","dir","div","dl","dt","fieldset","figcaption","figure","footer","form","frame","frameset","h1","h2","h3","h4","h5","h6","head","header","hr","html","iframe","legend","li","link","main","menu","menuitem","meta","nav","noframes","ol","optgroup","option","p","param","section","source","summary","table","tbody","td","tfoot","th","thead","title","tr","track","ul"].join("|")+")(?=(\\s|/?>|$))","i"),/^$/,!0],[new RegExp(_O.source+"\\s*$"),/^$/,!1]],yO=function(e,r,t,n){var s=e.bMarks[r]+e.tShift[r],o=e.eMarks[r],a,l,c,p;// if it's indented more than 3 spaces, it should be a code block
if(4<=e.sCount[r]-e.blkIndent)return!1;if(!e.md.options.html)return!1;if(60!==e.src.charCodeAt(s)/* < */)return!1;for(p=e.src.slice(s,o),a=0;a<kO.length&&!kO[a][0].test(p);a++);if(a===kO.length)return!1;if(n)// true if this sequence can be a terminator, false otherwise
return kO[a][2];// If we are here - we detected HTML block.
// Let's roll down till block end.
if(l=r+1,!kO[a][1].test(p))for(;l<t&&!(e.sCount[l]<e.blkIndent);l++)if(s=e.bMarks[l]+e.tShift[l],o=e.eMarks[l],p=e.src.slice(s,o),kO[a][1].test(p)){0!==p.length&&l++;break}return e.line=l,c=e.push("html_block","",0),c.map=[r,l],c.content=e.getLines(r,l,e.blkIndent,!0),!0},xO=function(e,r/*, endLine*/){var t=r+1,n=e.md.block.ruler.getRules("paragraph"),s=e.lineMax,o,a,c,p,u,d;// jump line-by-line until empty one or EOF
for(d=e.parentType,e.parentType="paragraph";t<s&&!e.isEmpty(t);t++)// this would be a code block normally, but after paragraph
// it's considered a lazy continuation regardless of what's there
if(!(3<e.sCount[t]-e.blkIndent)&&!(0>e.sCount[t]))// quirk for blockquotes, this line should already be checked by that rule
{for(a=!1,c=0,p=n.length;c<p;c++)if(n[c](e,t,s,!0)){a=!0;break}if(a)break}// Some tags can terminate paragraph without empty line.
return o=e.getLines(r,t,e.blkIndent,!1).trim(),e.line=t,u=e.push("paragraph_open","p",1),u.map=[r,e.line],u=e.push("inline","",0),u.content=o,u.map=[r,e.line],u.children=[],u=e.push("paragraph_close","p",-1),e.parentType=d,!0},vO=dB.isSpace;A.prototype.push=function(e,r,t){var n=new KB(e,r,t);return n.block=!0,0>t&&this.level--,n.level=this.level,0<t&&this.level++,this.tokens.push(n),n},A.prototype.isEmpty=function(e){return this.bMarks[e]+this.tShift[e]>=this.eMarks[e]},A.prototype.skipEmptyLines=function(e){for(var r=this.lineMax;e<r&&!(this.bMarks[e]+this.tShift[e]<this.eMarks[e]);e++);return e},A.prototype.skipSpaces=function(e){for(var r=this.src.length,t;e<r&&(t=this.src.charCodeAt(e),!!vO(t));e++);return e},A.prototype.skipSpacesBack=function(e,r){if(e<=r)return e;for(;e>r;)if(!vO(this.src.charCodeAt(--e)))return e+1;return e},A.prototype.skipChars=function(e,r){for(var t=this.src.length;e<t&&this.src.charCodeAt(e)===r;e++);return e},A.prototype.skipCharsBack=function(e,r,t){if(e<=t)return e;for(;e>t;)if(r!==this.src.charCodeAt(--e))return e+1;return e},A.prototype.getLines=function(e,r,t,n){var s=e,o,a,l,c,p,u,d;if(e>=r)return"";for(u=Array(r-e),o=0;s<r;s++,o++){for(a=0,d=c=this.bMarks[s],p=s+1<r||n?this.eMarks[s]+1:this.eMarks[s];c<p&&a<t;){if(l=this.src.charCodeAt(c),vO(l))9===l?a+=4-(a+this.bsCount[s])%4:a++;else if(c-d<this.tShift[s])a++;else break;c++}u[o]=a>t?Array(a-t+1).join(" ")+this.src.slice(c,p):this.src.slice(c,p)}return u.join("")},A.prototype.Token=KB;var qO=[// First 2 params - rule name & source. Secondary array - list of rules,
// which can be terminated by this one.
["table",tO,["paragraph","reference"]],["code",function(e,r,t/*, silent*/){var n,s,o;if(4>e.sCount[r]-e.blkIndent)return!1;for(s=n=r+1;n<t;){if(e.isEmpty(n)){n++;continue}if(4<=e.sCount[n]-e.blkIndent){n++,s=n;continue}break}return e.line=s,o=e.push("code_block","code",0),o.content=e.getLines(r,s,4+e.blkIndent,!0),o.map=[r,e.line],!0}],["fence",function(e,r,t,n){var s=!1,o=e.bMarks[r]+e.tShift[r],a=e.eMarks[r],i,l,c,p,u,d,h;// if it's indented more than 3 spaces, it should be a code block
if(4<=e.sCount[r]-e.blkIndent)return!1;if(o+3>a)return!1;if(i=e.src.charCodeAt(o),126!==i/* ~ */&&96!==i/* ` */)return!1;// scan marker length
if(u=o,o=e.skipChars(o,i),l=o-u,3>l)return!1;if(h=e.src.slice(u,o),c=e.src.slice(o,a),96===i&&0<=c.indexOf(Ae(i))/* ` */)return!1;// Since start is found, we can report success here in validation mode
if(n)return!0;// search end of block
for(p=r;;){if(p++,p>=t)// unclosed block should be autoclosed by end of document.
// also block seems to be autoclosed by end of parent
break;if(o=u=e.bMarks[p]+e.tShift[p],a=e.eMarks[p],o<a&&e.sCount[p]<e.blkIndent)// non-empty line with negative indent should stop the list:
// - ```
//  test
break;if(e.src.charCodeAt(o)===i&&!(4<=e.sCount[p]-e.blkIndent)&&(o=e.skipChars(o,i),!(o-u<l))&&(o=e.skipSpaces(o),!(o<a)))// closing code fence must be at least as long as the opening one
// closing fence should be indented less than 4 spaces
{s=!0;// found!
break}// make sure tail has spaces only
}// If a fence has heading spaces, they should be removed from its inner block
return l=e.sCount[r],e.line=p+(s?1:0),d=e.push("fence","code",0),d.info=c,d.content=e.getLines(r+1,p,l,!0),d.markup=h,d.map=[r,e.line],!0},["paragraph","reference","blockquote","list"]],["blockquote",sO,["paragraph","reference","blockquote","list"]],["hr",function(e,r,t,n){var s=e.bMarks[r]+e.tShift[r],o=e.eMarks[r],a,i,l,c;// if it's indented more than 3 spaces, it should be a code block
if(4<=e.sCount[r]-e.blkIndent)return!1;// Check hr marker
if(a=e.src.charCodeAt(s++),42!==a/* * */&&45!==a/* - */&&95!==a/* _ */)return!1;// markers can be mixed with spaces, but there should be at least 3 of them
for(i=1;s<o;){if(l=e.src.charCodeAt(s++),l!==a&&!oO(l))return!1;l===a&&i++}return!(3>i)&&(!!n||(e.line=r+1,c=e.push("hr","hr",0),c.map=[r,e.line],c.markup=Array(i+1).join(Ae(a)),!0))},["paragraph","reference","blockquote","list"]],["list",iO,["paragraph","reference","blockquote"]],["reference",pO],["heading",function(e,r,t,n){var s=e.bMarks[r]+e.tShift[r],o=e.eMarks[r],a,i,l,c;// if it's indented more than 3 spaces, it should be a code block
if(4<=e.sCount[r]-e.blkIndent)return!1;if(a=e.src.charCodeAt(s),35!==a/* # */||s>=o)return!1;// count heading level
for(i=1,a=e.src.charCodeAt(++s);35===a/* # */&&s<o&&6>=i;)i++,a=e.src.charCodeAt(++s);return!(6<i||s<o&&!uO(a))&&(!!n||(o=e.skipSpacesBack(o,s),l=e.skipCharsBack(o,35,s),l>s&&uO(e.src.charCodeAt(l-1))&&(o=l),e.line=r+1,c=e.push("heading_open","h"+(i+""),1),c.markup="########".slice(0,i),c.map=[r,e.line],c=e.push("inline","",0),c.content=e.src.slice(s,o).trim(),c.map=[r,e.line],c.children=[],c=e.push("heading_close","h"+(i+""),-1),c.markup="########".slice(0,i),!0));// Let's cut tails like '    ###  ' from the end of string
},["paragraph","reference","blockquote"]],["lheading",dO],["html_block",yO,["paragraph","reference","blockquote"]],["paragraph",xO]];S.prototype.tokenize=function(e,r,t){for(var n=this.ruler.getRules(""),s=n.length,o=r,a=!1,l=e.md.options.maxNesting,c,p;o<t&&(e.line=o=e.skipEmptyLines(o),!(o>=t))&&!(e.sCount[o]<e.blkIndent);){// If nesting level exceeded - skip tail to the end. That's not ordinary
// situation and we should not care about content.
if(e.level>=l){e.line=t;break}// Try all possible rules.
// On success, rule should:
//
// - update `state.line`
// - update `state.tokens`
// - return true
for(p=0;p<s&&(c=n[p](e,o,t,!1),!c);p++);// set state.tight if we had an empty line before current tag
// i.e. latest empty line should not count
e.tight=!a,e.isEmpty(e.line-1)&&(a=!0),o=e.line,o<t&&e.isEmpty(o)&&(a=!0,o++,e.line=o)}},S.prototype.parse=function(e,r,t,n){var s;e&&(s=new this.State(e,r,t,n),this.tokenize(s,s.line,s.lineMax))},S.prototype.State=A;for(var LO=S,wO=function(e,r){for(var t=e.pos;t<e.posMax&&!E(e.src.charCodeAt(t));)t++;return t!==e.pos&&(r||(e.pending+=e.src.slice(e.pos,t)),e.pos=t,!0)},CO=dB.isSpace,AO=function(e,r){var t=e.pos,n,s;if(10!==e.src.charCodeAt(t)/* \n */)return!1;// skip heading spaces for next line
for(n=e.pending.length-1,s=e.posMax,r||(0<=n&&32===e.pending.charCodeAt(n)?1<=n&&32===e.pending.charCodeAt(n-1)?(e.pending=e.pending.replace(/ +$/,""),e.push("hardbreak","br",0)):(e.pending=e.pending.slice(0,-1),e.push("softbreak","br",0)):e.push("softbreak","br",0)),t++;t<s&&CO(e.src.charCodeAt(t));)t++;return e.pos=t,!0},SO=dB.isSpace,EO=[],TO=0;256>TO;TO++)EO.push(0);["\\","!","\"","#","$","%","&","'","(",")","*","+",",",".","/",":",";","<","=",">","?","@","[","]","^","_","`","{","|","}","~","-"].forEach(function(e){EO[e.charCodeAt(0)]=1});var DO=function(e,r){var t=e.pos,n=e.src.charCodeAt(t),s,o,a,l,c;if(r)return!1;if(126!==n/* ~ */)return!1;if(o=e.scanDelims(e.pos,!0),l=o.length,c=Ae(n),2>l)return!1;for(l%2&&(a=e.push("text","",0),a.content=c,l--),s=0;s<l;s+=2)a=e.push("text","",0),a.content=c+c,e.delimiters.push({marker:n,length:0,// disable "rule of 3" length checks meant for emphasis
jump:s,token:e.tokens.length-1,end:-1,open:o.can_open,close:o.can_close});return e.pos+=o.length,!0},IO={tokenize:DO,postProcess:function(e){var r=e.tokens_meta,t=e.tokens_meta.length,n;for(T(e,e.delimiters),n=0;n<t;n++)r[n]&&r[n].delimiters&&T(e,r[n].delimiters)}},zO=function(e,r){var t=e.pos,n=e.src.charCodeAt(t),s,o,a;if(r)return!1;if(95!==n/* _ */&&42!==n/* * */)return!1;for(o=e.scanDelims(e.pos,42===n),s=0;s<o.length;s++)a=e.push("text","",0),a.content=Ae(n),e.delimiters.push({// Char code of the starting marker (number).
//
marker:n,// Total length of these series of delimiters.
//
length:o.length,// An amount of characters before this one that's equivalent to
// current one. In plain English: if this delimiter does not open
// an emphasis, neither do previous `jump` characters.
//
// Used to skip sequences like "*****" in one step, for 1st asterisk
// value will be 0, for 2nd it's 1 and so on.
//
jump:s,// A position of the token this delimiter corresponds to.
//
token:e.tokens.length-1,// If this delimiter is matched as a valid opener, `end` will be
// equal to its position, otherwise it's `-1`.
//
end:-1,// Boolean flags that determine if this delimiter could open or close
// an emphasis.
//
open:o.can_open,close:o.can_close});return e.pos+=o.length,!0},RO={tokenize:zO,postProcess:function(e){var r=e.tokens_meta,t=e.tokens_meta.length,n;for(D(e,e.delimiters),n=0;n<t;n++)r[n]&&r[n].delimiters&&D(e,r[n].delimiters)}},NO=dB.normalizeReference,MO=dB.isSpace,PO=dB.normalizeReference,VO=dB.isSpace,UO=/^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/,BO=/^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/,OO=bO.HTML_TAG_RE,jO=dB.has,GO=dB.isValidEntityCode,HO=dB.fromCodePoint,ZO=/^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i,FO=/^&([a-z][a-z0-9]{1,31});/i,$O=dB.isWhiteSpace,JO=dB.isPunctChar,YO=dB.isMdAsciiPunct;// Parse backticks
R.prototype.pushPending=function(){var e=new KB("text","",0);return e.content=this.pending,e.level=this.pendingLevel,this.tokens.push(e),this.pending="",e},R.prototype.push=function(e,r,t){this.pending&&this.pushPending();var n=new KB(e,r,t),s=null;return 0>t&&(this.level--,this.delimiters=this._prev_delimiters.pop()),n.level=this.level,0<t&&(this.level++,this._prev_delimiters.push(this.delimiters),this.delimiters=[],s={delimiters:this.delimiters}),this.pendingLevel=this.level,this.tokens.push(n),this.tokens_meta.push(s),n},R.prototype.scanDelims=function(e,r){var t=e,n=!0,s=!0,o=this.posMax,a=this.src.charCodeAt(e),i,l,c,p,u,d,h,m,g;// treat beginning of the line as a whitespace
for(i=0<e?this.src.charCodeAt(e-1):32;t<o&&this.src.charCodeAt(t)===a;)t++;return c=t-e,l=t<o?this.src.charCodeAt(t):32,h=YO(i)||JO(Ae(i)),g=YO(l)||JO(Ae(l)),d=$O(i),m=$O(l),m?n=!1:g&&!(d||h)&&(n=!1),d?s=!1:h&&!(m||g)&&(s=!1),r?(p=n,u=s):(p=n&&(!s||h),u=s&&(!n||g)),{can_open:p,can_close:u,length:c}},R.prototype.Token=KB;var WO=[["text",wO],["newline",AO],["escape",function(e,r){var t=e.pos,n=e.posMax,s;if(92!==e.src.charCodeAt(t)/* \ */)return!1;if(t++,t<n){if(s=e.src.charCodeAt(t),256>s&&0!==EO[s])return r||(e.pending+=e.src[t]),e.pos+=2,!0;if(10===s){// skip leading whitespaces from next line
for(r||e.push("hardbreak","br",0),t++;t<n&&(s=e.src.charCodeAt(t),!!SO(s));)t++;return e.pos=t,!0}}return r||(e.pending+="\\"),e.pos++,!0}],["backticks",function(e,r){var t=e.pos,n=e.src.charCodeAt(t),s,o,a,i,l,c;if(96!==n/* ` */)return!1;for(s=t,t++,o=e.posMax;t<o&&96===e.src.charCodeAt(t)/* ` */;)t++;for(a=e.src.slice(s,t),i=l=t;-1!==(i=e.src.indexOf("`",l));){for(l=i+1;l<o&&96===e.src.charCodeAt(l)/* ` */;)l++;if(l-i===a.length)return r||(c=e.push("code_inline","code",0),c.markup=a,c.content=e.src.slice(t,i).replace(/\n/g," ").replace(/^ (.+) $/,"$1")),e.pos=l,!0}return r||(e.pending+=a),e.pos+=a.length,!0}],["strikethrough",IO.tokenize],["emphasis",RO.tokenize],["link",function(e,r){var t="",n=e.pos,s=e.posMax,o=e.pos,a=!0,i,l,c,p,u,d,h,m,g,f;if(91!==e.src.charCodeAt(e.pos)/* [ */)return!1;// parser failed to find ']', so it's not a valid link
if(u=e.pos+1,p=e.md.helpers.parseLinkLabel(e,e.pos,!0),0>p)return!1;if(d=p+1,d<s&&40===e.src.charCodeAt(d)/* ( */){for(a=!1,d++;d<s&&(l=e.src.charCodeAt(d),MO(l)||10===l);d++);if(d>=s)return!1;// [link](  <href>  "title"  )
//          ^^^^^^ parsing link destination
for(o=d,h=e.md.helpers.parseLinkDestination(e.src,d,e.posMax),h.ok&&(t=e.md.normalizeLink(h.str),e.md.validateLink(t)?d=h.pos:t=""),o=d;d<s&&(l=e.src.charCodeAt(d),MO(l)||10===l);d++);// [link](  <href>  "title"  )
//                  ^^^^^^^ parsing link title
if(h=e.md.helpers.parseLinkTitle(e.src,d,e.posMax),d<s&&o!==d&&h.ok)// [link](  <href>  "title"  )
//                         ^^ skipping these spaces
for(g=h.str,d=h.pos;d<s&&(l=e.src.charCodeAt(d),MO(l)||10===l);d++);else g="";(d>=s||41!==e.src.charCodeAt(d)/* ) */)&&(a=!0),d++}if(a){//
// Link reference
//
if("undefined"==typeof e.env.references)return!1;if(d<s&&91===e.src.charCodeAt(d)/* [ */?(o=d+1,d=e.md.helpers.parseLinkLabel(e,d),0<=d?c=e.src.slice(o,d++):d=p+1):d=p+1,c||(c=e.src.slice(u,p)),m=e.env.references[NO(c)],!m)return e.pos=n,!1;t=m.href,g=m.title}//
// We found the end of the link, and know for a fact it's a valid link;
// so all that's left to do is to call tokenizer.
//
return r||(e.pos=u,e.posMax=p,f=e.push("link_open","a",1),f.attrs=i=[["href",t]],g&&i.push(["title",g]),e.md.inline.tokenize(e),f=e.push("link_close","a",-1)),e.pos=d,e.posMax=s,!0}],["image",function(e,r){var t="",n=e.pos,s=e.posMax,o,a,i,l,c,p,u,d,h,m,g,f,b;if(33!==e.src.charCodeAt(e.pos)/* ! */)return!1;if(91!==e.src.charCodeAt(e.pos+1)/* [ */)return!1;// parser failed to find ']', so it's not a valid link
if(p=e.pos+2,c=e.md.helpers.parseLinkLabel(e,e.pos+1,!1),0>c)return!1;if(u=c+1,u<s&&40===e.src.charCodeAt(u)/* ( */){for(u++;u<s&&(a=e.src.charCodeAt(u),VO(a)||10===a);u++);if(u>=s)return!1;// [link](  <href>  "title"  )
//          ^^^^^^ parsing link destination
for(b=u,h=e.md.helpers.parseLinkDestination(e.src,u,e.posMax),h.ok&&(t=e.md.normalizeLink(h.str),e.md.validateLink(t)?u=h.pos:t=""),b=u;u<s&&(a=e.src.charCodeAt(u),VO(a)||10===a);u++);// [link](  <href>  "title"  )
//                  ^^^^^^^ parsing link title
if(h=e.md.helpers.parseLinkTitle(e.src,u,e.posMax),u<s&&b!==u&&h.ok)// [link](  <href>  "title"  )
//                         ^^ skipping these spaces
for(m=h.str,u=h.pos;u<s&&(a=e.src.charCodeAt(u),VO(a)||10===a);u++);else m="";if(u>=s||41!==e.src.charCodeAt(u)/* ) */)return e.pos=n,!1;u++}else{//
// Link reference
//
if("undefined"==typeof e.env.references)return!1;if(u<s&&91===e.src.charCodeAt(u)/* [ */?(b=u+1,u=e.md.helpers.parseLinkLabel(e,u),0<=u?l=e.src.slice(b,u++):u=c+1):u=c+1,l||(l=e.src.slice(p,c)),d=e.env.references[PO(l)],!d)return e.pos=n,!1;t=d.href,m=d.title}//
// We found the end of the link, and know for a fact it's a valid link;
// so all that's left to do is to call tokenizer.
//
return r||(i=e.src.slice(p,c),e.md.inline.parse(i,e.md,e.env,f=[]),g=e.push("image","img",0),g.attrs=o=[["src",t],["alt",""]],g.children=f,g.content=i,m&&o.push(["title",m])),e.pos=u,e.posMax=s,!0}],["autolink",function(e,r){var t=e.pos,n,s,o,a,i,l;return 60===e.src.charCodeAt(t)/* < */&&(n=e.src.slice(t),!(0>n.indexOf(">"))&&(BO.test(n)?(s=n.match(BO),a=s[0].slice(1,-1),i=e.md.normalizeLink(a),!!e.md.validateLink(i))&&(r||(l=e.push("link_open","a",1),l.attrs=[["href",i]],l.markup="autolink",l.info="auto",l=e.push("text","",0),l.content=e.md.normalizeLinkText(a),l=e.push("link_close","a",-1),l.markup="autolink",l.info="auto"),e.pos+=s[0].length,!0):!!UO.test(n)&&(o=n.match(UO),a=o[0].slice(1,-1),i=e.md.normalizeLink("mailto:"+a),!!e.md.validateLink(i))&&(r||(l=e.push("link_open","a",1),l.attrs=[["href",i]],l.markup="autolink",l.info="auto",l=e.push("text","",0),l.content=e.md.normalizeLinkText(a),l=e.push("link_close","a",-1),l.markup="autolink",l.info="auto"),e.pos+=o[0].length,!0)))}],["html_inline",function(e,r){var t=e.pos,n,s,o,a;return!!e.md.options.html&&(o=e.posMax,!(60!==e.src.charCodeAt(t)/* < */||t+2>=o))&&(n=e.src.charCodeAt(t+1),33===n/* ! */||63===n/* ? */||47===n/* / */||I(n))&&(s=e.src.slice(t).match(OO),!!s)&&(r||(a=e.push("html_inline","",0),a.content=e.src.slice(t,t+s[0].length)),e.pos+=s[0].length,!0);// Check start
// Quick fail on second char
}],["entity",function(e,r){var t=e.pos,n=e.posMax,s,o,a;if(38!==e.src.charCodeAt(t)/* & */)return!1;if(t+1<n)if(s=e.src.charCodeAt(t+1),35===s/* # */){if(a=e.src.slice(t).match(ZO),a)return r||(o="x"===a[1][0].toLowerCase()?parseInt(a[1].slice(1),16):parseInt(a[1],10),e.pending+=GO(o)?HO(o):HO(65533)),e.pos+=a[0].length,!0;}else if(a=e.src.slice(t).match(FO),a&&jO(ZU,a[1]))return r||(e.pending+=ZU[a[1]]),e.pos+=a[0].length,!0;return r||(e.pending+="&"),e.pos++,!0}]],QO=[["balance_pairs",function(e){var r=e.tokens_meta,t=e.tokens_meta.length,n;for(z(e,e.delimiters),n=0;n<t;n++)r[n]&&r[n].delimiters&&z(e,r[n].delimiters)}],["strikethrough",IO.postProcess],["emphasis",RO.postProcess],["text_collapse",function(e){var r=0,t=e.tokens,n=e.tokens.length,s,o;for(s=o=0;s<n;s++)// closing tag
0>t[s].nesting&&r--,t[s].level=r,0<t[s].nesting&&r++,"text"===t[s].type&&s+1<n&&"text"===t[s+1].type?t[s+1].content=t[s].content+t[s+1].content:(s!==o&&(t[o]=t[s]),o++);s!==o&&(t.length=o)}]];// Parser rules
N.prototype.skipToken=function(e){var r=e.pos,t=this.ruler.getRules(""),n=t.length,s=e.md.options.maxNesting,o=e.cache,a,l;if("undefined"!=typeof o[r])return void(e.pos=o[r]);if(e.level<s)for(l=0;l<n&&(e.level++,a=t[l](e,!0),e.level--,!a);l++);else// Too much nesting, just skip until the end of the paragraph.
//
// NOTE: this will cause links to behave incorrectly in the following case,
//       when an amount of `[` is exactly equal to `maxNesting + 1`:
//
//       [[[[[[[[[[[[[[[[[[[[[foo]()
//
// TODO: remove this workaround when CM standard will allow nested links
//       (we can replace it by preventing links from being parsed in
//       validation mode)
//
e.pos=e.posMax;a||e.pos++,o[r]=e.pos},N.prototype.tokenize=function(e){for(var r=this.ruler.getRules(""),t=r.length,n=e.posMax,s=e.md.options.maxNesting,o,a;e.pos<n;){// Try all possible rules.
// On success, rule should:
//
// - update `state.pos`
// - update `state.tokens`
// - return true
if(e.level<s)for(a=0;a<t&&(o=r[a](e,!1),!o);a++);if(o){if(e.pos>=n)break;continue}e.pending+=e.src[e.pos++]}e.pending&&e.pushPending()},N.prototype.parse=function(e,r,t,n){var s=new this.State(e,r,t,n),o,a,l;for(this.tokenize(s),a=this.ruler2.getRules(""),l=a.length,o=0;o<l;o++)a[o](s)},N.prototype.State=R;var KO=N,XO=function e(r){var e={};// Use direct extract instead of `regenerate` to reduse browserified size
e.src_Any=iB.source,e.src_Cc=lB.source,e.src_Z=pB.source,e.src_P=FU.source,e.src_ZPCc=[e.src_Z,e.src_P,e.src_Cc].join("|"),e.src_ZCc=[e.src_Z,e.src_Cc].join("|");return e.src_pseudo_letter="(?:(?![><\uFF5C]|"+e.src_ZPCc+")"+e.src_Any+")",e.src_ip4="(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)",e.src_auth="(?:(?:(?!"+e.src_ZCc+"|[@/\\[\\]()]).)+@)?",e.src_port="(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?",e.src_host_terminator="(?=$|[><\uFF5C]|"+e.src_ZPCc+")(?!-|_|:\\d|\\.-|\\.(?!$|"+e.src_ZPCc+"))",e.src_path="(?:[/?#](?:(?!"+e.src_ZCc+"|[><\uFF5C]|[()[\\]{}.,\"'?!\\-]).|\\[(?:(?!"+e.src_ZCc+"|\\]).)*\\]|\\((?:(?!"+e.src_ZCc+"|[)]).)*\\)|\\{(?:(?!"+e.src_ZCc+"|[}]).)*\\}|\\\"(?:(?!"+e.src_ZCc+"|[\"]).)+\\\"|\\'(?:(?!"+e.src_ZCc+"|[']).)+\\'|\\'(?="+e.src_pseudo_letter+"|[-]).|\\.{2,4}[a-zA-Z0-9%/]|\\.(?!"+e.src_ZCc+"|[.]).|"+(r&&r["---"]?"\\-(?!--(?:[^-]|$))(?:-*)|"// `---` => long dash, terminate
:"\\-+|")+"\\,(?!"+e.src_ZCc+").|\\!(?!"+e.src_ZCc+"|[!]).|\\?(?!"+e.src_ZCc+"|[?]).)+|\\/)?",e.src_email_name="[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\\"\\.a-zA-Z0-9_]*",e.src_xn="xn--[a-z0-9\\-]{1,59}",e.src_domain_root=// Allow letters & digits (http://test1)
"(?:"+e.src_xn+"|"+e.src_pseudo_letter+"{1,63})",e.src_domain="(?:"+e.src_xn+"|(?:"+e.src_pseudo_letter+")|(?:"+e.src_pseudo_letter+"(?:-|"+e.src_pseudo_letter+"){0,61}"+e.src_pseudo_letter+"))",e.src_host="(?:(?:(?:(?:"+e.src_domain+")\\.)*"+e.src_domain/*_root*/+"))",e.tpl_host_fuzzy="(?:"+e.src_ip4+"|(?:(?:(?:"+e.src_domain+")\\.)+(?:%TLDS%)))",e.tpl_host_no_ip_fuzzy="(?:(?:(?:"+e.src_domain+")\\.)+(?:%TLDS%))",e.src_host_strict=e.src_host+e.src_host_terminator,e.tpl_host_fuzzy_strict=e.tpl_host_fuzzy+e.src_host_terminator,e.src_host_port_strict=e.src_host+e.src_port+e.src_host_terminator,e.tpl_host_port_fuzzy_strict=e.tpl_host_fuzzy+e.src_port+e.src_host_terminator,e.tpl_host_port_no_ip_fuzzy_strict=e.tpl_host_no_ip_fuzzy+e.src_port+e.src_host_terminator,e.tpl_host_fuzzy_test="localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:"+e.src_ZPCc+"|>|$))",e.tpl_email_fuzzy="(^|[><\uFF5C]|\"|\\(|"+e.src_ZCc+")("+e.src_email_name+"@"+e.tpl_host_fuzzy_strict+")",e.tpl_link_fuzzy=// Fuzzy link can't be prepended with .:/\- and non punctuation.
// but can start with > (markdown blockquote)
"(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|"+e.src_ZPCc+"))((?![$+<=>^`|\uFF5C])"+e.tpl_host_port_fuzzy_strict+e.src_path+")",e.tpl_link_no_ip_fuzzy=// Fuzzy link can't be prepended with .:/\- and non punctuation.
// but can start with > (markdown blockquote)
"(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|"+e.src_ZPCc+"))((?![$+<=>^`|\uFF5C])"+e.tpl_host_port_no_ip_fuzzy_strict+e.src_path+")",e},re={fuzzyLink:!0,fuzzyEmail:!0,fuzzyIP:!1},ej={"http:":{validate:function(e,r,t){var n=e.slice(r);return t.re.http||(t.re.http=new RegExp("^\\/\\/"+t.re.src_auth+t.re.src_host_port_strict+t.re.src_path,"i")),t.re.http.test(n)?n.match(t.re.http)[0].length:0}},"https:":"http:","ftp:":"http:","//":{validate:function(e,r,t){var n=e.slice(r);return t.re.no_http||(t.re.no_http=new RegExp("^"+t.re.src_auth+// Don't allow single-level domains, because of false positives like '//test'
// with code comments
"(?:localhost|(?:(?:"+t.re.src_domain+")\\.)+"+t.re.src_domain_root+")"+t.re.src_port+t.re.src_host_terminator+t.re.src_path,"i")),t.re.no_http.test(n)?3<=r&&":"===e[r-3]?0:3<=r&&"/"===e[r-3]?0:n.match(t.re.no_http)[0].length:0}},"mailto:":{validate:function(e,r,t){var n=e.slice(r);return t.re.mailto||(t.re.mailto=new RegExp("^"+t.re.src_email_name+"@"+t.re.src_host_strict,"i")),t.re.mailto.test(n)?n.match(t.re.mailto)[0].length:0}}},rj=["biz","com","edu","gov","net","org","pro","web","xxx","aero","asia","coop","info","museum","name","shop","\u0440\u0444"];W.prototype.add=function(e,r){return this.__schemas__[e]=r,$(this),this},W.prototype.set=function(e){return this.__opts__=M(this.__opts__,e),this},W.prototype.test=function(e){if(this.__text_cache__=e,this.__index__=-1,!e.length)return!1;var r,t,n,s,o,a,i,l,c;// try to scan for link with schema - that's the most simple rule
if(this.re.schema_test.test(e))for(i=this.re.schema_search,i.lastIndex=0;null!==(r=i.exec(e));)if(s=this.testSchemaAt(e,r[2],i.lastIndex),s){this.__schema__=r[2],this.__index__=r.index+r[1].length,this.__last_index__=r.index+r[0].length+s;break}return this.__opts__.fuzzyLink&&this.__compiled__["http:"]&&(l=e.search(this.re.host_fuzzy_test),0<=l&&(0>this.__index__||l<this.__index__)&&null!==(t=e.match(this.__opts__.fuzzyIP?this.re.link_fuzzy:this.re.link_no_ip_fuzzy))&&(o=t.index+t[1].length,(0>this.__index__||o<this.__index__)&&(this.__schema__="",this.__index__=o,this.__last_index__=t.index+t[0].length))),this.__opts__.fuzzyEmail&&this.__compiled__["mailto:"]&&(c=e.indexOf("@"),0<=c&&null!==(n=e.match(this.re.email_fuzzy))&&(o=n.index+n[1].length,a=n.index+n[0].length,(0>this.__index__||o<this.__index__||o===this.__index__&&a>this.__last_index__)&&(this.__schema__="mailto:",this.__index__=o,this.__last_index__=a))),0<=this.__index__},W.prototype.pretest=function(e){return this.re.pretest.test(e)},W.prototype.testSchemaAt=function(e,r,t){// If not supported schema check requested - terminate
return this.__compiled__[r.toLowerCase()]?this.__compiled__[r.toLowerCase()].validate(e,t,this):0},W.prototype.match=function(e){var r=0,t=[];// Try to take previous element from cache, if .test() called before
0<=this.__index__&&this.__text_cache__===e&&(t.push(Y(this,r)),r=this.__last_index__);// Scan string until end reached
for(// Cut head if cache was used
var n=r?e.slice(r):e;this.test(n);)t.push(Y(this,r)),n=n.slice(this.__last_index__),r+=this.__last_index__;return t.length?t:null},W.prototype.tlds=function(e,r){return(e=Array.isArray(e)?e:[e],!r)?(this.__tlds__=e.slice(),this.__tlds_replaced__=!0,$(this),this):(this.__tlds__=this.__tlds__.concat(e).sort().filter(function(e,r,t){return e!==t[r-1]}).reverse(),$(this),this)},W.prototype.normalize=function(e){e.schema||(e.url="http://"+e.url),"mailto:"!==e.schema||/^mailto:/i.test(e.url)||(e.url="mailto:"+e.url)},W.prototype.onCompile=function(){};var tj=W;/** Highest positive signed 32-bit float value */const nj=2147483647,sj=36,oj=1,aj=26,ij=72,lj=128,cj="-",pj=/^xn--/,uj=/[^\0-\x7E]/,dj=/[\x2E\u3002\uFF0E\uFF61]/g,hj={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},mj=sj-oj,gj=Ce,fj=Ae,bj=function(e){return 10>e-48?e-22:26>e-65?e-65:26>e-97?e-97:sj},_j=function(e,r){//  0..25 map to ASCII a..z or A..Z
// 26..35 map to ASCII 0..9
return e+22+75*(26>e)-((0!=r)<<5)},kj=function(e,r,t){let n=0;for(e=t?gj(e/700):e>>1,e+=gj(e/r);/* no initialization */e>mj*aj>>1;n+=sj)e=gj(e/mj);return gj(n+(mj+1)*e/(e+38))},yj=function(e){// Don't use UCS-2.
const r=[],s=e.length;let o=0,t=lj,a=ij,l=e.lastIndexOf(cj);0>l&&(l=0);for(let t=0;t<l;++t)128<=e.charCodeAt(t)&&Q("not-basic"),r.push(e.charCodeAt(t));// Main decoding loop: start just after the last delimiter if any basic code
// points were copied; start at the beginning otherwise.
for(let n=0<l?l+1:0,i;n<s;)/* no final expression */{i=o;for(let r=1,i=sj;;/* no condition */i+=sj){n>=s&&Q("invalid-input");const l=bj(e.charCodeAt(n++));(l>=sj||l>gj((nj-o)/r))&&Q("overflow"),o+=l*r;const c=i<=a?oj:i>=a+aj?aj:i-a;if(l<c)break;const t=sj-c;r>gj(nj/t)&&Q("overflow"),r*=t}const l=r.length+1;a=kj(o-i,l,0==i),gj(o/l)>nj-t&&Q("overflow"),t+=gj(o/l),o%=l,r.splice(o++,0,t)}return we(...r)},xj=function(e){const r=[];// Convert the input in UCS-2 to an array of Unicode code points.
e=te(e);// Cache the length.
let t=e.length,s=lj,o=0,a=ij;// Initialize the state.
// Handle the basic code points.
for(const t of e)128>t&&r.push(fj(t));let i=r.length,l=i;// Main encoding loop:
for(i&&r.push(cj);l<t;){// All non-basic code points < n have been handled already. Find the next
// larger one:
let t=nj;for(const r of e)r>=s&&r<t&&(t=r);// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
// but guard against overflow.
const n=l+1;t-s>gj((nj-o)/n)&&Q("overflow"),o+=(t-s)*n,s=t;for(const t of e)if(t<s&&++o>nj&&Q("overflow"),t==s){// Represent delta as a generalized variable-length integer.
let e=o;for(let n=sj;;/* no condition */n+=sj){const s=n<=a?oj:n>=a+aj?aj:n-a;if(e<s)break;const t=e-s,o=sj-s;r.push(fj(_j(s+t%o,0))),e=gj(t/o)}r.push(fj(_j(e,0))),a=kj(o,n,l==i),o=0,++l}++o,++s}return r.join("")},vj={/**
	   * A string representing the current Punycode.js version number.
	   * @memberOf punycode
	   * @type String
	   */version:"2.1.0",/**
	   * An object of methods to convert from JavaScript's internal character
	   * representation (UCS-2) to Unicode code points, and back.
	   * @see <https://mathiasbynens.be/notes/javascript-encoding>
	   * @memberOf punycode
	   * @type Object
	   */ucs2:{decode:te,encode:e=>we(...e)},decode:yj,encode:xj,toASCII:function(e){return X(e,function(e){return uj.test(e)?"xn--"+xj(e):e})},toUnicode:function(e){return X(e,function(e){return pj.test(e)?yj(e.slice(4).toLowerCase()):e})}};// aka. 0x7FFFFFFF or 2^31-1
/** Bootstring parameters */ // markdown-it default options
var qj={default:{options:{html:!1,// Enable HTML tags in source
xhtmlOut:!1,// Use '/' to close single tags (<br />)
breaks:!1,// Convert '\n' in paragraphs into <br>
langPrefix:"language-",// CSS language prefix for fenced blocks
linkify:!1,// autoconvert URL-like texts to links
// Enable some language-neutral replacements + quotes beautification
typographer:!1,// Double + single quotes replacement pairs, when typographer enabled,
// and smartquotes on. Could be either a String or an Array.
//
// For example, you can use '«»„“' for Russian, '„“‚‘' for German,
// and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
quotes:"\u201C\u201D\u2018\u2019",/* “”‘’ */ // Highlighter function. Should return escaped HTML,
// or '' if the source string is not changed and should be escaped externaly.
// If result starts with <pre... internal wrapper is skipped.
//
// function (/*str, lang*/) { return ''; }
//
highlight:null,maxNesting:100// Internal protection, recursion limit
},components:{core:{},block:{},inline:{}}},zero:{options:{html:!1,// Enable HTML tags in source
xhtmlOut:!1,// Use '/' to close single tags (<br />)
breaks:!1,// Convert '\n' in paragraphs into <br>
langPrefix:"language-",// CSS language prefix for fenced blocks
linkify:!1,// autoconvert URL-like texts to links
// Enable some language-neutral replacements + quotes beautification
typographer:!1,// Double + single quotes replacement pairs, when typographer enabled,
// and smartquotes on. Could be either a String or an Array.
//
// For example, you can use '«»„“' for Russian, '„“‚‘' for German,
// and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
quotes:"\u201C\u201D\u2018\u2019",/* “”‘’ */ // Highlighter function. Should return escaped HTML,
// or '' if the source string is not changed and should be escaped externaly.
// If result starts with <pre... internal wrapper is skipped.
//
// function (/*str, lang*/) { return ''; }
//
highlight:null,maxNesting:20// Internal protection, recursion limit
},components:{core:{rules:["normalize","block","inline"]},block:{rules:["paragraph"]},inline:{rules:["text"],rules2:["balance_pairs","text_collapse"]}}},commonmark:{options:{html:!0,// Enable HTML tags in source
xhtmlOut:!0,// Use '/' to close single tags (<br />)
breaks:!1,// Convert '\n' in paragraphs into <br>
langPrefix:"language-",// CSS language prefix for fenced blocks
linkify:!1,// autoconvert URL-like texts to links
// Enable some language-neutral replacements + quotes beautification
typographer:!1,// Double + single quotes replacement pairs, when typographer enabled,
// and smartquotes on. Could be either a String or an Array.
//
// For example, you can use '«»„“' for Russian, '„“‚‘' for German,
// and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
quotes:"\u201C\u201D\u2018\u2019",/* “”‘’ */ // Highlighter function. Should return escaped HTML,
// or '' if the source string is not changed and should be escaped externaly.
// If result starts with <pre... internal wrapper is skipped.
//
// function (/*str, lang*/) { return ''; }
//
highlight:null,maxNesting:20// Internal protection, recursion limit
},components:{core:{rules:["normalize","block","inline"]},block:{rules:["blockquote","code","fence","heading","hr","html_block","lheading","list","reference","paragraph"]},inline:{rules:["autolink","backticks","emphasis","entity","escape","html_inline","image","link","newline","text"],rules2:["balance_pairs","emphasis","text_collapse"]}}}},Lj=/^(vbscript|javascript|file|data):/,wj=/^data:image\/(gif|png|jpeg|webp);/,Cj=["http:","https:","mailto:"];// "Zero" preset, with nothing enabled. Useful for manual configuring of simple
ie.prototype.set=function(e){return dB.assign(this.options,e),this},ie.prototype.configure=function(e){var r=this,t;if(dB.isString(e)&&(t=e,e=qj[t],!e))throw new Error("Wrong `markdown-it` preset \""+t+"\", check name");if(!e)throw new Error("Wrong `markdown-it` preset, can't be empty");return e.options&&r.set(e.options),e.components&&Object.keys(e.components).forEach(function(t){e.components[t].rules&&r[t].ruler.enableOnly(e.components[t].rules),e.components[t].rules2&&r[t].ruler2.enableOnly(e.components[t].rules2)}),this},ie.prototype.enable=function(e,r){var t=[];Array.isArray(e)||(e=[e]),["core","block","inline"].forEach(function(r){t=t.concat(this[r].ruler.enable(e,!0))},this),t=t.concat(this.inline.ruler2.enable(e,!0));var n=e.filter(function(e){return 0>t.indexOf(e)});if(n.length&&!r)throw new Error("MarkdownIt. Failed to enable unknown rule(s): "+n);return this},ie.prototype.disable=function(e,r){var t=[];Array.isArray(e)||(e=[e]),["core","block","inline"].forEach(function(r){t=t.concat(this[r].ruler.disable(e,!0))},this),t=t.concat(this.inline.ruler2.disable(e,!0));var n=e.filter(function(e){return 0>t.indexOf(e)});if(n.length&&!r)throw new Error("MarkdownIt. Failed to disable unknown rule(s): "+n);return this},ie.prototype.use=function(e/*, params, ... */){var r=[this].concat(Array.prototype.slice.call(arguments,1));return e.apply(e,r),this},ie.prototype.parse=function(e,r){if("string"!=typeof e)throw new Error("Input data should be a String");var t=new this.core.State(e,this,r);return this.core.process(t),t.tokens},ie.prototype.render=function(e,r){return r=r||{},this.renderer.render(this.parse(e,r),this.options,r)},ie.prototype.parseInline=function(e,r){var t=new this.core.State(e,this,r);return t.inlineMode=!0,this.core.process(t),t.tokens},ie.prototype.renderInline=function(e,r){return r=r||{},this.renderer.render(this.parseInline(e,r),this.options,r)};var Aj={false:"push",true:"unshift"},Sj=Object.prototype.hasOwnProperty,e=function e(r,s){s=Object.assign({},e.defaults,s),r.core.ruler.push("anchor",function(e){var t={},n=e.tokens,a=Array.isArray(s.level)?(o=s.level,function(e){return o.includes(e)}):function(r){return function(t){return t>=r}}(s.level),o;n.filter(function(e){return"heading_open"===e.type}).filter(function(e){return a(+e.tag.substr(1))}).forEach(function(a){var r=n[n.indexOf(a)+1].children.filter(function(e){return"text"===e.type||"code_inline"===e.type}).reduce(function(r,t){return r+t.content},""),o=a.attrGet("id");null==o&&(o=function(e,n){for(var r=e,s=2;Sj.call(n,r);)r=e+"-"+s++;return n[r]=!0,r}(s.slugify(r),t),a.attrPush(["id",o])),s.permalink&&s.renderPermalink(o,s,e,n.indexOf(a)),s.callback&&s.callback(a,{slug:o,title:r})})})};e.defaults={level:1,slugify:function(e){return encodeURIComponent((e+"").trim().toLowerCase().replace(/\s+/g,"-"))},permalink:!1,renderPermalink:function(n,e,r,t){var s=[Object.assign(new r.Token("link_open","a",1),{attrs:[["class",e.permalinkClass],["href",e.permalinkHref(n,r)],["aria-hidden","true"]]}),Object.assign(new r.Token("html_block","",0),{content:e.permalinkSymbol}),new r.Token("link_close","a",-1)],o;e.permalinkSpace&&s[Aj[!e.permalinkBefore]](Object.assign(new r.Token("text","",0),{content:" "})),(o=r.tokens[t+1].children)[Aj[e.permalinkBefore]].apply(o,s)},permalinkClass:"header-anchor",permalinkSpace:!0,permalinkSymbol:"\xB6",permalinkBefore:!1,permalinkHref:function(e){return"#"+e}};// Process definition lists
var r=/\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g,n=/\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;// Process ^superscript^
const Ej={regex:/\{\+\+([\s\S]*?)\+\+\}/g,validate:()=>!0,annotate(e){return ve({type:"addition"},e)},render(e,r){return""===r.trim()?"\n\n<ins class=\"break\">&nbsp;</ins>\n\n":"<ins>".concat(r,"</ins>")}},Tj={regex:/\{\x2D\x2D([\s\S]*?)\x2D\x2D\}/g,validate:()=>!0,annotate(e){return ve({type:"deletion"},e)},render(e,r){return""===r.trim()?"<del>&nbsp;</del> ":"<del>".concat(r,"</del>")}},Dj={regex:/\{~~([\s\S]*?)~>([\s\S]*?)~~\}/g,validate:()=>!0,annotate(e){return ve({type:"substitution"},e)},render(e,r,t){return Tj.render(e,r)+Ej.render(e,t).trimLeft()}},Ij="==}",zj={regex:/\{>>([\s\S]*?)<<\}/g,validate:e=>{let{input:r,index:t}=e;return r.substr(t-Ij.length,Ij.length)!==Ij},annotate(e){return ve({type:"comment"},e)},render(e,r){return"<span class=\"critic comment\">".concat(r,"</span>")}},Rj={regex:/\{==([\s\S]*?)==\}\{>>([\s\S]*?)<<\}/g,validate:()=>!0,annotate(e){return ve({type:"highlight"},e)},render(e,r,t){return"<mark>".concat(r,"</mark>").concat(zj.render(e,t))}},Nj=new ie("commonmark");Nj.set({typographer:!0}),Nj.enable("replacements").enable("table"),Nj.use(e,[1,2,3]).use(function(e){// Search `[:~][\n ]`, returns next pos after marker on success
// or -1 on fail.
function r(e,r){var t=e.bMarks[r]+e.tShift[r],n=e.eMarks[r],s,o;return t>=n?-1:(o=e.src.charCodeAt(t++),126!==o/* ~ */&&58!==o/* : */)?-1:(s=e.skipSpaces(t),t===s?-1:s>=n?-1:t);// Check bullet
// no empty definitions, e.g. "  : "
}function t(e,r){var t=e.level+2,n,s;for(n=r+2,s=e.tokens.length-2;n<s;n++)e.tokens[n].level===t&&"paragraph_open"===e.tokens[n].type&&(e.tokens[n+2].hidden=!0,e.tokens[n].hidden=!0,n+=2)}var n=e.utils.isSpace;e.block.ruler.before("paragraph","deflist",function(e,s,o,a){var i,l,c,p,u,d,h,m,g,f,b,_,k,y,x,v,q,L,w,C;if(a)// quirk: validation mode validates a dd block only, not a whole deflist
return!(0>e.ddIndent)&&0<=r(e,s);if(g=s+1,g>=o)return!1;if(e.isEmpty(g)&&(g++,g>=o))return!1;if(e.sCount[g]<e.blkIndent)return!1;if(l=r(e,g),0>l)return!1;// Start list
h=e.tokens.length,w=!0,C=e.push("dl_open","dl",1),C.map=d=[s,0],p=s,c=g;// One definition list can contain multiple DTs,
// and one DT can be followed by multiple DDs.
//
// Thus, there is two loops here, and label is
// needed to break out of the second one
//
/*eslint no-labels:0,block-scoped-var:0*/OUTER:for(;;){for(L=!1,C=e.push("dt_open","dt",1),C.map=[p,p],C=e.push("inline","",0),C.map=[p,p],C.content=e.getLines(p,p+1,e.blkIndent,!1).trim(),C.children=[],C=e.push("dt_close","dt",-1);;){for(C=e.push("dd_open","dd",1),C.map=u=[g,0],q=l,m=e.eMarks[c],f=e.sCount[c]+l-(e.bMarks[c]+e.tShift[c]);q<m&&(i=e.src.charCodeAt(q),n(i));)9===i?f+=4-f%4:f++,q++;if(l=q,v=e.tight,b=e.ddIndent,_=e.blkIndent,x=e.tShift[c],y=e.sCount[c],k=e.parentType,e.blkIndent=e.ddIndent=e.sCount[c]+2,e.tShift[c]=l-e.bMarks[c],e.sCount[c]=f,e.tight=!0,e.parentType="deflist",e.md.block.tokenize(e,c,o,!0),(!e.tight||L)&&(w=!1),L=1<e.line-c&&e.isEmpty(e.line-1),e.tShift[c]=x,e.sCount[c]=y,e.tight=v,e.parentType=k,e.blkIndent=_,e.ddIndent=b,C=e.push("dd_close","dd",-1),u[1]=g=e.line,g>=o)break OUTER;if(e.sCount[g]<e.blkIndent)break OUTER;if(l=r(e,g),0>l)break;c=g}if(g>=o)break;if(p=g,e.isEmpty(p))break;if(e.sCount[p]<e.blkIndent)break;if(c=p+1,c>=o)break;if(e.isEmpty(c)&&c++,c>=o)break;if(e.sCount[c]<e.blkIndent)break;if(l=r(e,c),0>l)break;// go to the next loop iteration:
// insert DT and DD tags and repeat checking
}// Finilize list
return C=e.push("dl_close","dl",-1),d[1]=g,e.line=g,w&&t(e,h),!0},{alt:["paragraph","reference"]})}).use(function(e){e.inline.ruler.after("emphasis","sup",ce)}).use(function(e){e.inline.ruler.after("emphasis","sub",pe)}).use(function(e){function r(e){var r=e.tokens,a,c,p,u,d,h,g,f,b,_,k,y,x;if(e.env.abbreviations)for(y=new RegExp("(?:"+Object.keys(e.env.abbreviations).map(function(e){return e.substr(1)}).sort(function(e,r){return r.length-e.length}).map(t).join("|")+")"),k="(^|"+s+"|"+o+"|["+[" ","\r","\n","$","+","<","=",">","^","`","|","~"].map(t).join("")+"])("+Object.keys(e.env.abbreviations).map(function(e){return e.substr(1)}).sort(function(e,r){return r.length-e.length}).map(t).join("|")+")($|"+s+"|"+o+"|["+[" ","\r","\n","$","+","<","=",">","^","`","|","~"].map(t).join("")+"])",b=new RegExp(k,"g"),(c=0,p=r.length);c<p;c++)if("inline"===r[c].type)// We scan from the end, to keep position when new tags added.
for(u=r[c].children,a=u.length-1;0<=a;a--)if((x=u[a],"text"===x.type)&&(f=0,h=x.content,b.lastIndex=0,g=[],!!y.test(h)))// fast regexp run to determine whether there are any abbreviated words
// in the current token
{for(;_=b.exec(h);)(0<_.index||0<_[1].length)&&(d=new e.Token("text","",0),d.content=h.slice(f,_.index+_[1].length),g.push(d)),d=new e.Token("abbr_open","abbr",1),d.attrs=[["title",e.env.abbreviations[":"+_[2]]]],g.push(d),d=new e.Token("text","",0),d.content=_[2],g.push(d),d=new e.Token("abbr_close","abbr",-1),g.push(d),b.lastIndex-=_[3].length,f=b.lastIndex;g.length&&(f<h.length&&(d=new e.Token("text","",0),d.content=h.slice(f),g.push(d)),r[c].children=u=n(u,a,g))}}var t=e.utils.escapeRE,n=e.utils.arrayReplaceAt,s=e.utils.lib.ucmicro.P.source,o=e.utils.lib.ucmicro.Z.source;// ASCII characters in Cc, Sc, Sm, Sk categories we should terminate on;
// you can check character classes here:
// http://www.unicode.org/Public/UNIDATA/UnicodeData.txt
e.block.ruler.before("reference","abbr_def",function(e,r,t,n){var s=e.bMarks[r]+e.tShift[r],o=e.eMarks[r],a,i,l,c,p;if(s+2>=o)return!1;if(42!==e.src.charCodeAt(s++)/* * */)return!1;if(91!==e.src.charCodeAt(s++)/* [ */)return!1;for(c=s;s<o;s++){if(l=e.src.charCodeAt(s),91===l/* [ */)return!1;if(93===l/* ] */){p=s;break}else 92===l/* \ */&&s++}return!(0>p||58!==e.src.charCodeAt(p+1)/* : */)&&(!!n||(a=e.src.slice(c,p).replace(/\\(.)/g,"$1"),i=e.src.slice(p+2,o).trim(),0!==a.length)&&0!==i.length&&(e.env.abbreviations||(e.env.abbreviations={}),"undefined"==typeof e.env.abbreviations[":"+a]&&(e.env.abbreviations[":"+a]=i),e.line=r+1,!0))},{alt:["paragraph","reference"]}),e.core.ruler.after("linkify","abbr_replace",r)}).use(function(e){// Process footnote block definition
// Process inline footnotes (^[...])
// Process footnote references ([^...])
// Glue footnote tokens to end of token stream
function r(e){var r=!1,n={},s,o,a,c,p,u,d,h,m,g;if(e.env.footnotes&&(e.tokens=e.tokens.filter(function(e){return"footnote_reference_open"===e.type?(r=!0,m=[],g=e.meta.label,!1):"footnote_reference_close"===e.type?(r=!1,n[":"+g]=m,!1):(r&&m.push(e),!r)}),!!e.env.footnotes.list)){for(u=e.env.footnotes.list,d=new e.Token("footnote_block_open","",1),e.tokens.push(d),(s=0,o=u.length);s<o;s++){for(d=new e.Token("footnote_open","",1),d.meta={id:s,label:u[s].label},e.tokens.push(d),u[s].tokens?(h=[],d=new e.Token("paragraph_open","p",1),d.block=!0,h.push(d),d=new e.Token("inline","",0),d.children=u[s].tokens,d.content=u[s].content,h.push(d),d=new e.Token("paragraph_close","p",-1),d.block=!0,h.push(d)):u[s].label&&(h=n[":"+u[s].label]),e.tokens=e.tokens.concat(h),p="paragraph_close"===e.tokens[e.tokens.length-1].type?e.tokens.pop():null,c=0<u[s].count?u[s].count:1,a=0;a<c;a++)d=new e.Token("footnote_anchor","",0),d.meta={id:s,subId:a,label:u[s].label},e.tokens.push(d);p&&e.tokens.push(p),d=new e.Token("footnote_close","",-1),e.tokens.push(d)}d=new e.Token("footnote_block_close","",-1),e.tokens.push(d)}}var t=e.helpers.parseLinkLabel,n=e.utils.isSpace;e.renderer.rules.footnote_ref=he,e.renderer.rules.footnote_block_open=me,e.renderer.rules.footnote_block_close=fe,e.renderer.rules.footnote_open=be,e.renderer.rules.footnote_close=_e,e.renderer.rules.footnote_anchor=ke,e.renderer.rules.footnote_caption=de,e.renderer.rules.footnote_anchor_name=ue,e.block.ruler.before("reference","footnote_def",function(e,r,t,s){var o=e.bMarks[r]+e.tShift[r],a=e.eMarks[r],i,l,c,p,u,d,h,m,g,f,b;// line should be at least 5 chars - "[^x]:"
if(o+4>a)return!1;if(91!==e.src.charCodeAt(o)/* [ */)return!1;if(94!==e.src.charCodeAt(o+1)/* ^ */)return!1;for(u=o+2;u<a;u++){if(32===e.src.charCodeAt(u))return!1;if(93===e.src.charCodeAt(u)/* ] */)break}if(u===o+2)return!1;// no empty footnote labels
if(u+1>=a||58!==e.src.charCodeAt(++u)/* : */)return!1;if(s)return!0;for(u++,e.env.footnotes||(e.env.footnotes={}),e.env.footnotes.refs||(e.env.footnotes.refs={}),d=e.src.slice(o+2,u-2),e.env.footnotes.refs[":"+d]=-1,h=new e.Token("footnote_reference_open","",1),h.meta={label:d},h.level=e.level++,e.tokens.push(h),i=e.bMarks[r],l=e.tShift[r],c=e.sCount[r],p=e.parentType,b=u,m=g=e.sCount[r]+u-(e.bMarks[r]+e.tShift[r]);u<a&&(f=e.src.charCodeAt(u),n(f));)9===f?g+=4-g%4:g++,u++;return e.tShift[r]=u-b,e.sCount[r]=g-m,e.bMarks[r]=b,e.blkIndent+=4,e.parentType="footnote",e.sCount[r]<e.blkIndent&&(e.sCount[r]+=e.blkIndent),e.md.block.tokenize(e,r,t,!0),e.parentType=p,e.blkIndent-=4,e.tShift[r]=l,e.sCount[r]=c,e.bMarks[r]=i,h=new e.Token("footnote_reference_close","",-1),h.level=--e.level,e.tokens.push(h),!0},{alt:["paragraph","reference"]}),e.inline.ruler.after("image","footnote_inline",function(e,r){var n=e.posMax,s=e.pos,o,a,i,l,c;return!(s+2>=n)&&94===e.src.charCodeAt(s)/* ^ */&&91===e.src.charCodeAt(s+1)/* [ */&&(o=s+2,a=t(e,s+1),!(0>a))&&(r||(!e.env.footnotes&&(e.env.footnotes={}),!e.env.footnotes.list&&(e.env.footnotes.list=[]),i=e.env.footnotes.list.length,e.md.inline.parse(e.src.slice(o,a),e.md,e.env,c=[]),l=e.push("footnote_ref","",0),l.meta={id:i},e.env.footnotes.list[i]={content:e.src.slice(o,a),tokens:c}),e.pos=a+1,e.posMax=n,!0);// We found the end of the link, and know for a fact it's a valid link;
// so all that's left to do is to call tokenizer.
//
}),e.inline.ruler.after("footnote_inline","footnote_ref",function(e,r){var t=e.posMax,n=e.pos,s,o,a,i,l;// should be at least 4 chars - "[^x]"
if(n+3>t)return!1;if(!e.env.footnotes||!e.env.footnotes.refs)return!1;if(91!==e.src.charCodeAt(n)/* [ */)return!1;if(94!==e.src.charCodeAt(n+1)/* ^ */)return!1;for(o=n+2;o<t;o++){if(32===e.src.charCodeAt(o))return!1;if(10===e.src.charCodeAt(o))return!1;if(93===e.src.charCodeAt(o)/* ] */)break}return o!==n+2&&!(o>=t)&&(o++,s=e.src.slice(n+2,o-1),"undefined"!=typeof e.env.footnotes.refs[":"+s])&&(r||(!e.env.footnotes.list&&(e.env.footnotes.list=[]),0>e.env.footnotes.refs[":"+s]?(a=e.env.footnotes.list.length,e.env.footnotes.list[a]={label:s,count:0},e.env.footnotes.refs[":"+s]=a):a=e.env.footnotes.refs[":"+s],i=e.env.footnotes.list[a].count,e.env.footnotes.list[a].count++,l=e.push("footnote_ref","",0),l.meta={id:a,subId:i,label:s}),e.pos=o,e.posMax=t,!0);// no empty footnote labels
}),e.core.ruler.after("inline","footnote_tail",r)}).use(function(e){e.core.ruler.before("block","critic-markup",Le)});const Mj=Nj.parse.bind(Nj),Pj=Nj.render.bind(Nj);return t.parse=Mj,t.render=Pj,t}({});
